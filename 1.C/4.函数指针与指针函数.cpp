
//函数参数：函数参数是从右往左被压入栈中的

//函数指针与指针函数

//函数指针
定义：函数指针，其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。 
int (*f)(int x); //声明一个函数指针
f=func;  //将func函数的首地址赋给指针f
f=&func;  //和上一行一样，取地址符不是必须的


#include<stdio.h>
int Max(int a,int b)
{
	return a>b?a:b;
}

int main()
{
	int (*Pfun)(int,int) = Max;     //Pfun函数指针
	int max = Pfun(10,20);
	printf("%d",max);
	return 0;
}


//指针函数
定义：指针函数，简单的来说，就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。 
int *fun(int x,int y);
首先它是一个函数，只不过这个函数的返回值是一个地址值。函数返回值必须用同类型的指针变量来接受，也就是说，指针函数一定有函数返回值，而且，在主调函数中，函数返回值必须赋给同类型的指针变量。

float *fun();
float *p;
p = fun(a);

函数指针：int (*Pfun)(int,int)
指针函数：int * Pfun(int,int)
再简单一点，可以这样辨别两者：函数名带*带括号的就是函数指针，带*不带括号就是指针函数。

补充：返回引用(函数返回值这种带&) 和返回对象的例子见 技巧/返回对象和返回引用.cpp


//函数的返回值是如何带出函数的

小于4个字节：函数将返回值存储在eax寄存器中，返回调用方之后在读取eax寄存器的值  

大于4字节小于等于8字节：函数返回值通过两个寄存器，eax和edx存储返回后读取。 //指针就是通过这个返回的，

大于8字节的返回值：将利用临时对象进行返回值的传递    //说简单点就是先把返回值复制到临时对象中，再把临时对象中的值拷贝到main函数中的变量，两次拷贝
	首先在mian函数中的栈上开辟一片额外的空间作为临时对象  
	调用函数时将该临时对象的地址通过隐藏的参数传递给函数
	函数内部将返回值的数据拷贝到临时对象，并将临时对象的地址通过寄存器eax传出。
	函数返回后，将eax指向的临时对象的内存拷贝到main函数中的变量
	
注意：在返回自定义类型时，无论自定义类型的大小是多少都是通过临时变量进行传递的

//extern关键字
修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。

如果文件a.c需要引用b.c中变量int k，就可以在a.c中声明extern int k，然后就可以引用变量k。
这里需要注意的是，被引用的变量k的链接属性必须是外链接（external）的，也就是说a.c要引用到k，不只是取决于在a.c中声明extern int k，还取决于变量k本身是能够被引用到的。
这涉及到c语言中变量的作用域。能够被其他模块以extern修饰符引用到的变量通常是全局变量。 //如果b.c中的是局部变量k,那就不能在a.c中引用

调用外部函数或变量有两种方式，一个是#include ,一个是extern,,在预编译的时候，extern明显快一些

比如在C++中调用C库函数，就需要在C++程序中用 extern "C" 声明要引用的函数。
这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C++和C程序编译完成后在目标代码中命名规则不同。


file1.c:
int arr[80];

file2.c:
extern int *arr;   //错误引用，类型不兼容，正确写法：extern int arr[]


//作用阈规则
data段：保存已经初始化的全局变量(包括全局静态变量和普通变量) 和 已经初始化的局部静态变量
text段：保存已经初始化的普通局部变量 和 程序执行代码          //注意：未初始化的普通局部变量也在这里
bss段： 保存没有初始化的全局变量 和 没有初始化的局部静态变量  //注意：初始化为0也算是未初始化，


由于被 static 修饰的变量总是存在内存的静态区，所以即使这个函数运行结束，这个静态变量的值还是不会被销毁，函数下次使用时仍然能用到这个值
静态变量的作用域都是当前cpp

#include<stdio.h>

int data1 = 10;  // data1为普通全局变量

void Fun1()
{
	data1++;
	printf("%d\n",data1);  //输出 11 12 13···20
} 

void Fun2()
{
	int data2 = 10;    // data2为普通局部变量
	data2++;
	printf("%d\n",data2);   //输出 11 11 11···11
}

static int data3 = 10;   // data3为静态全局变量
void Fun3()
{
	data3++;
	printf("%d\n",data3);   //输出 11 12 13···20
}

void Fun4()
{
	static int data4 = 10;  // data4为静态局部变量
	data4++;
	printf("%d\n",data4);    //输出 11 12 13···20
}

int main()
{
	for(int i = 0;i < 10;i++)
	{
		Fun1();
		Fun2();
		Fun3();
		Fun4();
	}
	return 0;
}



//bss段的作用是什么？

一般C语言的编译后执行语句都编译成机器代码，保存在.text段；已初始化的全局变量和局部静态变量都保存在. data段；

未初始化的全局变量和局部静态变量一般放在一个叫.“bss”的段里。 我们知道未初始化的全局变量和局部静态变量默认值都为0，本来它们也可以被放在.data段的，但是因为它们都是0，所以为它们在.data段分配空间并且存放数据0是没有必要的。 

程序运行的时候它们的确是要占内存空间的，并且可执行文件必须记录所有未初始化的全局变量和局部静态变量的大小总和，记为.bss段。 
所以bss段只是为未初始化的全局变量和局部静态变量预留位置而已，它并没有内容，所以它在文件中也不占据空间。text和data段都在可执行文件中（在嵌入式系统里一般是固化在镜像文件中），由系统从可执行文件中加载；而bss段不在可执行文件中，由系统初始化。

前面说的内存映像图
内存映像图：
					内容               权限
栈区          函数中的普通变量  		wr
堆区            动态申请的内存 			wr
静态变量区    static修饰的变量			wr
数据区		 用于初始化变量的常量		r
代码区		   	   代码指令				r

各存储器在内存中的位置分布
低位                                                  高位
1      2      3      4      5      6     7     8       9


以32位系统为例，内存空间4G
1.不可用空间：0-128M
2.text段：可执行指令，字面值常量，具有常属性且被初始化的全局变量和静态局部变量，注：字面值常量：true false 0x(16进制) 0(8进制) l(长整型) 各种转义符(\n)等 		 	，如果带了0x等量的数为常属性变量
3.data段：保存已经初始化的全局变量和静态局部变量
4.bss段：未被初始化的全局变量和静态局部变量
//注意：2-4的大小是在程序运行前就固定的，程序运行期间是不会改的,同时text和data在可执行文件中
5.堆区：动态分配内存，程序运行时需要内存空间的时候申请
6.堆栈增长的预留空间：存储共享库，共享内存等
7.栈区：非静态局部变量
8.命令行和参数和环境变量
10.内核空间
	内核空间分为3部分：
	低16M：ZONE_DMA直接访问内存
	中间的892M：ZONE_NORMAL
	高的128M：ZONE_HIGHMEM高端内存
	
//程序运行起来至少需要 text data 栈