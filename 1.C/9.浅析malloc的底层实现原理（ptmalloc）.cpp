
//浅析malloc的底层实现原理（ptmalloc）  ptmalloc可以看成一个分配器，管理内存资源（已分配的和未分配的），brk()和mmap()都是ptmalloc的分配机制

brk()和sbrk() 和 mmap函数

brk（）的参数设置为新的brk上界地址，成功返回1，失败返回0；
sbrk（）的参数为申请内存的大小，返回heap新的上界brk的地址 

munmap函数用于释放内存。

//内存管理的一般方法
1.C风格的内存管理
就是通过malloc和free进行内存管理，通过调用brk和mmap进行添加额外的虚拟内存
需要保持长期存储的程序并不适合使用 malloc()来管理内存。如果有大量的不固定的内存(动态内存)引用，经常难以知道它们何时被释放。

2.池式内存管理
内存池是一种半内存管理方法。 就是将程序分为几个阶段，每个阶段分配特定的内存空间，
比如：网络服务器收到请求后生成很多进程，每个进程都会被分配特定大小的空间，内存的最大生存期限为当前连接的存在期

3.引用计数
在引用计数中，所有共享的数据结构都有一个域来包含当前活动“引用”结构的次数。 
当一个进程访问该数据结构的时候，引用计数+1，结束访问后，引用计数-1。当计数为0的时候，释放该空间

4.垃圾收集
垃圾收集是全自动地检测并移除不再使用的数据对象。垃圾收集器通常会在当可用内存减少到少于一个具体的阈值时运行。
它们以程序所知的可用的一组“基本”数据：栈数据、全局变量、寄存器等作为出发点。然后它们尝试去追踪通过这些数据连接到每一块数据。收集器找到的都是有用的数据；它没有找到的就是垃圾，可以被销毁并重新使用这些无用的数据。为了有效地管理内存，很多类型的垃圾收集器都需要知道数据结构内部指针的规划，所以，为了正确运行垃圾收集器，它们必须是语言本身的一部分。


//malloc 实现原理

因为brk、sbrk、mmap都属于系统调用，若每次申请内存，都调用这三个，那么每次都会产生系统调用，影响性能；其次，这样申请的内存容易产生碎片，因为堆是从低地址到高地址，如果高地址的内存没有被释放，低地址的内存就不能被回收。

因此，malloc采用的是内存池的管理方式（ptmalloc），ptmalloc 采用边界标记法将内存划分成很多块，从而对内存的分配与回收进行管理。为了内存分配函数malloc的高效性，ptmalloc会预先向操作系统申请一块内存供用户使用，当我们申请和释放内存的时候，ptmalloc会将这些内存管理起来，并通过一些策略来判断是否将其回收给操作系统。这样做的最大好处就是，使用户申请和释放内存的时候更加高效，避免产生过多的内存碎片

注意：brk和mmap都是ptmalloc的分配机制，ptmalloc把内存分成很多块，然后按块分配内存(有点集装箱的意思)，比如：每一块都是2k,如果申请8k，就分配四块内存，当free以后，又可以按2k为单位分配内存。也有点内存对齐的意思。这样就可以避免过多的内存碎片

//ptmalloc简介

ptmalloc 实现了 malloc()，free()以及一组其它的函数。以提供动态内存管理的支持。
分配器处在用户程序和内核之间，它响应用户的分配请求，向操作系统申请内存，然后将其返回给用户程序，为了保持高效的分配，分配器一般都会预先分配一块大于用户请求的内存，并通过某种算法管理这块内存，来满足用户的内存分配要求，用户释放掉的内存也并不是立即就返回给操作系统，相反，分配器会管理这些被释放掉的空闲空间，以应对用户以后的内存分配要求。
也就是说，分配器不但要管理已分配的内存块，还需要管理空闲的内存块，当响应用户分配要求时，分配器会首先在空闲空间中寻找一块合适的内存给用户，在空闲空间中找不到的情况下才分配一块新的内存。为实现一个高效的分配器，需要考虑很多的因素。比如，分配器本身管理内存块所占用的内存空间必须很小，分配算法必须要足够的快。

//内存管理数据结构概述

//主分配区和非主分配区
每个进程只有一个主分配区，但可能存在多个非主分配区，他们之间是通过环形链表连接，ptmalloc 根据系统对分配的争用情况动态增加非主分配区的数量，分配区的数量一旦增加，就不会再减少了。主分配区可以访问进程的 heap 区域和 mmap 映射区域，也就是说主分配区可以使用 sbrk 和 mmap向操作系统申请虚拟内存。而非主分配区只能访问进程的 mmap 映射区域，不能访问heap区。

所有分配区对于线程都是互斥的，只能同时允许一个进程同时对该分配区进行访问。//只要是线程访问分配区，无论是访问 申请空间 释放空间 都要先获得该分配区的锁，

如果主分配区的内存是通过 mmap()向系统分配的，当 free 该内存时，主分配区会直接调用 munmap()将该内存归还给系统。

当某一线程需要调用 malloc()分配内存空间时，
该线程先查看线程私有变量中是否已经存在一个分配区，如果存在，尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果失败，该线程搜索循环链表试图获得一个没有加锁的分配区。如果所有的分配区都已经加锁，那么 malloc()会开辟一个新的分配区，把该分配区加入到全局分配区循环链表并加锁，然后使用该分配区进行分配内存操作。

在释放操作中，线程同样试图获得待释放内存块所在分配区的锁，如果该分配区正在被别的线程使用，则需要等待直到其他线程释放该分配区的互斥锁之后才可以进行释放操作。

申请小块内存时会产生很多内存碎片，ptmalloc 在整理时也需要对分配区做加锁操作。

由于频繁加锁，会导致malloc性能下降，一次加锁操作需要消耗 100ns 左右，正是锁的缘故，导致 ptmalloc在多线程竞争情况下性能远远落后于 tcmalloc。

//chunk组织
用户请求分配的空间在 ptmalloc 中都使用一个 chunk 来表示，用户调用 free()函数释放掉的内存也并不是立即就归还给操作系统，相反，它们也会被表示为一个 chunk，就是在ptmalloc中，是使用chunk表示这些内存，通过堆chunk的管理来管理未释放内存。

当chunk正在使用的时候，有三个标志符：P M A;
P:p=0时，表示前一个chunk为空闲,p=1时，表示前一个chunk正在使用,只有当p=0的时候，才可以对当前chunk进行合并,ptmalloc 分配的第一个块总是将p设为1, 以防止程序引用到不存在的区域
M:M=1 为mmap映射区域分配；M=0为heap区域分配
A:A=0 为主分配区分配；A=1 为非主分配区分配。

当chunk空闲时，其M状态是不存在的，只有AP状态
原本是用户数据区的地方存储了四个指针
指针fd指向后一个空闲的chunk，而bk指向前一个空闲的chunk，malloc通过这两个指针将大小相近的chunk连成一个 双向链表 。
在large bin中的空闲chunk，还有两个指针，fd_nextsize和bk_nextsize，用于加快在large bin中查找最近匹配的空闲chunk。不同的chunk链表又是通过bins或者fastbins来组织的。

//关于fast bins ,Unsorted Bin,small bins,large bins,Top chunk,mmaped chunk,Last remainder chunk,以及内存的合并、拆分、匹配的细节，要去看原址https://zhaoyang.blog.csdn.net/article/details/90670471

//ptmalloc 的响应用户内存分配要求的具体步骤为：

1.获取分配区的锁，防止多线程冲突。
2.计算出实际需要分配的内存的chunk实际大小
3.判断chunk的大小，如果小于max_fast（64Ｂ），则尝试去fast bins上取适合的chunk，如果有则分配结束。否则，下一步；
4.判断chunk大小是否小于512B，如果是，则从small bins上去查找chunk，如果有合适的，则分配结束。否则下一步；
5.ptmalloc首先会遍历 fast bins 中的chunk，将相邻的chunk进行合并，并链接到unsorted bin 中然后遍历 unsorted bins。如果 unsorted bins 上只有一个chunk并且大于待分配的chunk，则进行切割，并且剩余的chunk继续扔回 unsorted bins；如果 unsorted bins 上有大小和待分配chunk相等的，则返回，并从 unsorted bins删除；如果 unsorted bins 中的某一chunk大小属于 small bins 的范围，则放入small bins的头部；如果 unsorted bins 中的某一chunk大小属于 large bins 的范围，则找到合适的位置放入。若未分配成功，转入下一步；
6.从 large bins 中查找找到合适的chunk之后，然后进行切割，一部分分配给用户，剩下的放入 unsorted bin 中。
7.如果搜索 fast bins 和 bins 都没有找到合适的chunk，那么就需要操作top chunk来进行分配了。当 top chunk 大小比用户所请求大小还大的时候，top chunk会分为两个部分：User chunk（用户请求大小）和 Remainder chunk（剩余大小）。其中 Remainder chunk 成为新的 top chunk。 当 top chunk 大小小于用户所请求的大小时，top chunk就通过sbrk（main arena）或mmap（thread arena）系统调用来扩容。
8.到了这一步，说明 top chunk 也不能满足分配要求，所以，于是就有了两个选择: 如果是主分配区，调用 sbrk()，增加 top chunk 大小；如果是非主分配区，调用 mmap 来分配一个新的 sub-heap，增加 top chunk 大小；或者使用 mmap()来直接分配。在这里，需要依靠 chunk 的大小来决定到底使用哪种方法。判断所需分配的 chunk 大小是否大于等于 mmap 分配阈值，如果是的话，则转下一步，调用 mmap 分配， 否则跳到第 10 步，增加 top chunk 的大小。
9.使用 mmap 系统调用为程序的内存空间映射一块 chunk_size align 4kB 大小的空间。 然后将内存指针返回给用户。
10.判断是否为第一次调用 malloc，若是主分配区，则需要进行一次初始化工作，分配一块大小为(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap。若已经初始化过了，主分配区则调用 sbrk()增加 heap 空间，分主分配区则在 top chunk 中切 割出一个 chunk，使之满足分配需求，并将内存指针返回给用户。

/*简而言之： 获取分配区(arena)并加锁→→ fast bin→→unsorted bin→→small bin→→large bin→→top chunk→→扩展堆*/

//内存回收概述
free() 函数接受一个指向分配区域的指针作为参数，释放该指针所指向的 chunk。
而具体的释放方法则根据该 chunk 所处的位置和该 chunk 的大小而定。free()函数的工作步骤如下：

1.获取分配区的锁，保证线程安全。
2.如果free的是空指针，则返回，什么都不做。
3.判断当前 chunk 是否是 mmap 映射区域映射的内存，如果是，则直接munmap()释放这块内存。前面的已使用chunk的数据结构中，我们可以看到有M来标识是否是mmap映射的内存。
4.判断 chunk 是否与 top chunk 相邻，如果相邻，则直接和top chunk合并（和top chunk相邻相当于和分配区中的空闲内存块相邻）。转到步骤8
5.如果chunk的大小大于max_fast（64b），则放入unsorted bin，并且检查是否有合并，有合并情况并且和 top chunk 相邻，则转到步骤8；没有合并情况则free。
6.如果chunk的大小小于 max_fast（64b），则直接放入fast bin，fast bin并没有改变chunk的状态。没有合并情况，则free；有合并情况，转到步骤7
7.在fast bin，如果当前chunk的下一个chunk也是空闲的，则将这两个chunk合并，放入unsorted bin上面。合并后的大小如果大于64B，会触发进行fast bins的合并操作，fast bins中的chunk将被遍历，并与相邻的空闲chunk进行合并，合并后的chunk会被放到unsorted bin中，fast bin会变为空。合并后的chunk和topchunk相邻，则会合并到topchunk中。转到步骤8
8.判断 top chunk 的大小是否大于 mmap 收缩阈值（默认为128KB），如果是的话，对于主分配区，则会试图归还 top chunk 中的一部分给操作系统。free结束。


//使用注意事项
为了避免Glibc内存暴增，需要注意：

1.后分配的内存先释放，因为ptmalloc收缩内存是从top chunk开始，如果与top chunk相邻的chunk不能释放，top chunk以下的chunk都无法释放。
2.ptmalloc不适合用于管理长生命周期的内存，特别是持续不定期分配和释放长生命周期的内存，这将导致ptmalloc内存暴增。
3.不要关闭 ptmalloc 的 mmap 分配阈值动态调整机制，因为这种机制保证了短生命周期的 内存分配尽量从 ptmalloc 缓存的内存 chunk 中分配，更高效，浪费更少的内存。
4.多线程分阶段执行的程序不适合用ptmalloc，这种程序的内存更适合用内存池管理 。
5.尽量减少程序的线程数量和避免频繁分配/释放内存。频繁分配，会导致锁的竞争，最终导致非主分配区增加，内存碎片增高，并且性能降低。
6.防止内存泄露，ptmalloc对内存泄露是相当敏感的，根据它的内存收缩机制，如果与top chunk相邻的那个chunk没有回收，将导致top chunk一下很多的空闲内存都无法返回给操作系统。
7.防止程序分配过多的内存，或是由于glibc内存暴增，导致系统内存耗尽，程序因为OOM被系统杀掉。预估程序可以使用的最大物理内存的大小，配置系统的/proc/sys/vm/overcommit_memory ,/proc/sys/vm/overcommit_ratio,以及使用ulimit -v限制程序能使用的虚拟内存的大小，防止程序因OOM被杀死掉。


