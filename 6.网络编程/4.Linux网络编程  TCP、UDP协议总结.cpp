

//Linux网络编程  TCP、UDP协议总结



1、为什么TCP客户端最后还要发送一次确认呢，为什么不采用两次握手的方式进行连接？
主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。
如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。
如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

2、什么TIME_WAIT状态必须等待2MSL的时间？

,/可靠的终止TCP连接、保证让迟来的TCP报文段有足够的时间被丢弃掉。
第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，服务器已经发送了FIN + ACK报文请求断开了，客户端还没有给我回应，
应该是服务器发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。


3、为什么建立连接是三次握手，关闭连接确是四次挥手？
建立连接的时候，服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。


简单的说，
关闭连接确是四次挥手：	客户端发送FIN报文，表示不再发送消息，希望关闭此次连接，
						服务器收到FIN报文后，回复表示已经收到，
												如果也同意关闭，就发送一个FIN+ACK的报文，
												如果不同意，还有数据没有发送给客户端，就发送这些数据，然后再发FIN+ACK，
						客户端收到服务器的FIN+ACK报文，发送ACK报文，然后进入TIME_WAIT，到此，四次挥手结束

TIME_WAIT存在原因：		如果服务器发送的FIN+ACK报文之后，服务器没有收到回复，就会在TIME_WAIT时间内重发，客户端收到之后，
						重新计时TIME_WAIT，然后发送回复信息
						
4、如果已经建立了连接，但是客户端突然出现故障了怎么办？
TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

//TCP拥塞控制的方法
,/TCP进行拥塞控制的方法共有四种：慢启动、拥塞避免、快速重传和快速恢复
关于拥塞控制，滑动窗口见PDF



//TCP协议和UDP协议的区别
1,TCP面向连接，UDP是无连接的，即发送数据之前不需要建立连接。
2,TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；而UDP尽最大努力交付，即不保证可靠交付
3,TCP通过校验和、拥塞控制、序号标识、滑动窗口、应答确认、超时重传等机制实现可靠传输。
3,UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
4,每一条TCP连接只能是点到点的，而UDP支持一对一，一对多，多对一和多对多的交互通信。
5,TCP对系统资源要求较多，UDP对系统资源要求较少。

简单说：TCP:一对一的可靠传输，保证发送的都能收到，但是占用资源多
		UDP:可一对多的不可靠传输，不保证发送都能收到，但是效率高，占用资源少，