

//浅析Linux守护进程、守护进程的创建步骤

何为守护进程
守护进程(daemon)是一类在后台运行的特殊进程，其生存期较长，独立于控制终端、执行特定的系统任务。


进程组
,/进程组：每个进程都属于一个进程组，进程组中可以包含一个或多个进程。
	当父进程，创建子进程的时候，默认子进程与父进程属于同一进程组。
	组长进程可以创建一个进程组，创建该进程组中的进程，然后终止。只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。
	进程组生存期：进程组创建到最后一个进程离开(终止或转移到另一个进程组)。

会话
,/会话：多个进程组构成一个会话，建立会话的进程是会话的领导进程，即会话首进程，该进程 ID 为会话的 SID。
	创建会话的进程不能是组长进程，创建会话的进程变成 新会话首进程
	,/若调用进程是组长进程，则出错返回
	建立新会话时，先调用fork，父进程终止，子进程调用setsid

如果创建会话进程非组长进程，那么就能创建一个新会话：
	该进程变成新会话的首进程
	该进程成为一个新进程组的组长进程
	该进程没有控制终端，如果之前有，则会被中断（会话过程对控制终端的独占性）
	也就是说：组长进程不能成为新会话首进程，新会话首进程必定成为组长进程。
	
守护进程的创建步骤
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <sys/stat.h>

int main()
{
	/* 1、创建子进程，父进程退出 */
	if (fork() != 0)
	{
		exit(0);
	}

	/* 2、setsid()创建会话 */
	setsid();
	
	/* 3、再次fork，父进程退出，即使新进程不再是会话首进程 */
	if (fork() != 0)
	{
		exit(0);
	}
	
	/* 4、让根目录成为子进程的工作目录 */
	chdir("/");

	/* 5、清空掩码，大大增强该守护进程的灵活性 */
	umask(0);

	/* 6、清空所有文件描述符，让其不占用系统资源 */
	int maxfd = getdtablesize();
	int i = 0;
	for (; i < maxfd; ++i)
	{
		close(i);
	}

	/* 每隔5s将当前时间写入日志文件 */
	while (1)
	{
		FILE* fp = fopen("/home/zy/Learn/a.log", "a+");
		if (fp == NULL)
		{
			break;
		}

		time_t tv;
		time(&tv);
		fprintf(fp, "Time is %s", asctime(localtime(&tv)));
		fclose(fp);
		sleep(5);
	}

	exit(0);
}
