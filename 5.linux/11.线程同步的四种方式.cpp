

线程同步的四种方式：

互斥锁
条件变量
信号量
读写锁

//互斥锁
在线程里也有一把锁——互斥锁（mutex），互斥锁是一种简单的加锁的方法来控制对共享资源的访问，互斥锁只有两种状态,即上锁( lock )和解锁( unlock )。

互斥锁的特点：
1,原子性：把一个互斥量锁定为一个原子操作，这意味着操作系统（或pthread函数库）保证了如果一个线程锁定了一个互斥量，没有其他线程在同一时间可以成功锁定这个互斥量；
2,唯一性：如果一个线程锁定了一个互斥量，在它解除锁定之前，没有其他线程可以锁定这个互斥量；
3,非繁忙等待：如果一个线程已经锁定了一个互斥量，第二个线程又试图去锁定这个互斥量，则第二个线程将被挂起（不占用任何cpu资源），
	直到第一个线程解除对这个互斥量的锁定为止，第二个线程则被唤醒并继续执行，同时锁定这个互斥量。

//条件变量

与互斥锁不同，条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直 到某特殊情况发生为止。通常条件变量和互斥锁同时使用。

1,一个线程等待"条件变量的条件成立"而挂起；
2,另一个线程使 “条件成立”（给出条件成立信号）唤醒等待线程。

原理：
条件的检测是在互斥锁的保护下进行的。线程在改变条件状态之前必须首先锁住互斥量。如果一个条件为假，一个线程自动阻塞，并释放等待状态改变的互斥锁。如果另一个线程改变了条件，它发信号给关联的条件变量，唤醒一个或多个等待它的线程，重新获得互斥锁，重新评价条件。如果两进程共享可读写的内存，条件变量 可以被用来实现这两进程间的线程同步。


//信号量
信号量广泛用于进程或线程间的同步和互斥，信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问。
就是PV操作，见pdf


//读写锁
分为读锁和写锁
如果一个线程用读锁锁定了临界区，那么其他线程也可以用读锁来进入临界区，这样就可以多个线程并行操作。但这个时候，如果再进行写锁加锁就会发生阻塞，写锁请求阻塞后，后面如果继续有读锁来请求，这些后来的读锁都会被阻塞 ! 

简单的说读锁可以共享临界区，但是写锁不行，写锁上锁后，后面的进程想访问就要阻塞