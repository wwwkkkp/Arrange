

//理解Linux五种I/O模型、同步I/O与异步I/O、阻塞与非阻塞

五种IO模型
5种IO模型分别是阻塞式IO、非阻塞式IO、IO复用(如select和wpoll)、信号驱动IO(SIGIO)、异步IO(POSIX的aio_系列函数)；前4种为同步IO操作，只有异步IO模型是异步IO操作。


Blocking I/O模型
进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。

特点：
	进程阻塞挂起不消耗CPU资源，及时响应每个操作；
	实现难度低、开发应用较容易；
	适用并发量小的网络应用开发；
	不适用并发量大的应用：因为一个请求IO会阻塞进程，所以，得为每请求分配一个处理进程（线程）以及时响应，系统开销大。


Non-Blocking I/O模型
,/当用户进程发出recvfrom操作时，如果kernel中的数据还没有准备好，那么它并不会阻塞用户进程，而是立刻返回一个error。
从用户进程角度讲，它发起一个recvfrom操作后，并不需要等待，而是马上就得到了一个结果。
用户进程收到返回结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送recvfrom操作/**（不断的轮询）*/

特点：
	进程轮询（重复）调用，消耗CPU的资源；
	实现难度高、开发应用相对阻塞IO模式较难；
	适用并发量较小、且不需要及时响应的网络应用开发；
	
I/O Multiplexing模型
就是先用select函数去向内核申请数据，如果没有准备好，就看可以选择是阻塞还是非阻塞，直到准备好以后返回，然后调用recvfrom函数去拷贝数据
selct函数的特点是可以同时处理多个连接，如果设置成非阻塞模式，就是轮询，可以轮询多个进程的申请，如果准备好了就告诉申请进程，然后调用recvfrom函数去拷贝数据

特点：
	专一进程解决多个进程I/O的阻塞问题，性能好；Reactor模式;
	实现、开发应用难度较大；
	适用高并发服务应用开发：一个进程（线程）响应多个请求；
	
Signal-driven I/O模型 信号驱动IO模型
当开启了信号驱动功能时，首先发起一个信号处理的系统调用，如sigaction()，这个系统调用会立即返回。但数据在准备好时，会发送SIGIO信号，进程收到这个信号就知道数据准备好了，于是发起操作数据的系统调用，

特点：
	回调机制，实现、开发应用难度大；


Asynchronous I/O模型
当进程发起一个IO操作，进程返回（不阻塞），但也不能返回结果；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。
就是数据会直接赋值到进程缓冲区，完成以后，才通知进程已经复制完成。

特点：
	不阻塞，数据一步到位；Proactor模式；
	需要操作系统的底层支持，LINUX 2.5 版本内核首现，2.6 版本产品的内核标准特性；
	实现、开发应用难度大；
	非常适合高性能高并发应用；
	


同步I/O与异步I/O
	同步I/O操作(synchronous IO)：导致请求进程阻塞，直到I/O操作完成
	异步I/O操作(asynchronous IO)：不导致请求进程阻塞
先说说同步和异步，同步和异步关注的是双方的消息通信机制：
	同步：双方的动作是经过双方协调的，步调一致的。
	异步：双方并不需要协调，都可以随意进行各自的操作。



总结
明确I/O请求的两个阶段：

数据准备阶段：I/O请求一般需要请求特殊的资源（如磁盘、RAM、文件），当资源被上一个使用者使用没有被释放时，IO请求就会被阻塞，直到能够使用这个资源。
数据复制阶段：真正进行数据接收和发生。

在数据准备阶段，IO分为阻塞IO和非阻塞IO。

阻塞IO：资源不可用时，IO请求一直阻塞，直到反馈结果（有数据或超时）。
非阻塞IO：资源不可用时，IO请求离开返回，返回数据标识资源不可用。

在数据复制阶段，IO分为同步IO和异步IO。

同步IO：应用阻塞在发送或接收数据的状态，直到数据成功传输或返回失败，用户需要自行处理数据。
异步IO：应用发送或接收数据后立刻返回(不会阻塞)，数据写入OS缓存，由OS完成数据发送或接收，并返回成功或失败的信息给应用，用户无需自行处理数据，由内核处理完毕直接通知用户

