
//8.管道

Linux的进程间通信的方法有 管道、消息队列、信号量、共享内存、套接口 等。其中，管道又分为命名管道和无名管道。消息队列、信号量、共享内存统称为系统(POSIX和System V系统)IPC。管道、消息队列、信号量和共享内存用于本地进程间通信，而套接口用于远程进程间通信。下面进行简单介绍：
1,	管道（Pipe）及命名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制,
	/因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；
2,	消息（Message）队列（报文队列）：消息队列是消息的链接表，包括Posix消息队列system V消息队列。
	有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息;
	/消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
	
3,	共享内存：**使得多个进程可以访问同一块内存空间,/是最快的可用IPC形式。
	**是针对其他通信机制运行效率较低而设计的;/往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
	
4,	信号量（semaphore）:/主要作为进程间以及同一进程不同线程之间的同步手段。

5,	套接口（Socket）：也称套接字,/是更为一般的进程间通信机制，可用于不同机器之间的进程间通信。
	起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。



//什么是管道
管道是Linux/UNIX系统中比较原始的进程间通信形式,/它实现数据以一种数据流的方式，在多进程间流动。在系统中其相当于文件系统上的一个文件，来缓存所要传输的数据。

特点：
1,管道没有名字的，称为匿名管道。
2,/管道是半双工的（至少在大多数系统是这样的），数据只能向一个方向流动。需要双方通信时，需要建立起两个管道。
3,/匿名管道只能用于父子进程或兄弟进程之间（具有亲缘关系的进程）
4,单独构成一种独立的文件系统。管道对于管道两端的进程而言，就是一个文件，
	但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。
5,数据的读出和写入:/一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。
6,/管道的缓冲区是有限的/（管道只存在于内存中，在管道创建时，为缓冲区分配一个页面大小）。
7,/管道所传送的是无格式字节流/，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令，或记录）等。


//匿名管道
管道的创建与关闭
#include <unisted>
int pipe(int fd[2]); //其中fd[0]是 读出端 的文件描述符，fd[1]是 写入端 的文件描述符。当函数成功返回后，则自动维护了一个 从fd[1]到fd[0]的数据通道。

管道的两端是固定了任务的。即管道的读出端只能用于读取数据，管道的写入端只能用于写入数据;/管道是异步通信

当对一个读端已经关闭的管道进行写操作时，会产生信号 SIGPIPE，说明管道读端已经关闭，并且write操作返回-1，errno的值设为EPIPE，对于SIGPIPE信号可以进行捕捉处理。
如果写入进程不能捕捉或者干脆忽略SIGPIPE信号，则写入进程会中断。


管道的读取规则是：
1,如果管道的写端不存在，则认为已经读到了管道的末尾，读函数返回的读出字节数为0；
2,当管道的写端存在时，如果请求的字节数目大于PIPE_BUF，则返回管道中现有的字节数
3,如果请求的字节数目不大于PIPE_BUF，则返回管道中现有的数据字节数

管道的写入规则是：
向管道中写入数据时，管道缓冲区一旦有空闲区域，写进程就会立即试图向管道中写入数据，如果读进程未读取管道缓冲区中的数据，那么写操作将一直阻塞。

父进程利用管道向子进程发送消息:
	#include <fcntl.h>
	#include <stdio.h>
	#include <assert.h>
	#include <unistd.h>
	#include <string.h>
	#include <stdlib.h>

	int main()
	{
		int fd[2];//fd[0]r fd[1]w 
		pipe(fd);   //因为无名管道是父子之间的通信，所以相当于开辟了一个缓冲区，父进程和子进程都可以读写

		pid_t pid = fork();
		assert(pid != -1);
		if(pid == 0)  //子进程
		{
			close(fd[1]);  //关闭写通道
			char buff[128] = {0};
			read(fd[0],buff,127);
			printf("[child]buff:%s\n",buff);
			close(fd[0]);
		}
		else
		{
			close(fd[0]);  //关闭读通道
			printf("[parent]input:");
			char buff[128]={0};
			fgets(buff,128,stdin);  //stdin：标准输入
			write(fd[1], buff, strlen(buff));
			close(fd[1]);
		}
		exit(0);
	}



//有名管道克服了管道没有名字的限制
命名管道（name pipe）也称为FIFO，它一种文件类型，在文件系统中可以看到它，创建一个FIFO文件类似于创建一个普通文件。
FIFO(first input first output)总是按照先进先出的原则工作，第一个被写入的数据将首先从管道中读出
,/即使进程与创建FIFO的进程不存在亲缘关系，只要可以访问该路径，就能够通过FIFO相互通信，因此，通过FIFO不相关的进程也能交换数据。

命名管道与管道的区别
1,	命名管道可以用于任何两个进程间通信，而并不限制这两个进程同源，因此命名管道的使用比管道的使用要灵活方便的多。
2,	命名管道作为一种特殊的文件存放于文件系统中，而不是像管道一样存放于内存（使用完毕后消失）;
	/当进程对命名管道的使用结束后，命名管道依然存放于文件系统中，除非对其进行删除操作，否则该命名管道不会消失。

创建有名管道就相当于创建了一个文件，进程可以打开这个文件进行读写，
在shell下执行 
mkfifo my_fifo 
就会生成一个名字为my_fifo的有名管道

/*若要删除一个命名管道，则使用系统调用unlink。*/具体可以看代码

读规则：
当以读的方式打开有名管道的时候，如果这时有其他进程在读数据，或者管道中没有数据，那这个进程会进入阻塞状态，直到有进程向其中写新数据。
如果FIFO中有数据，读操作不会因为FIFO中的字节数少于请求的字节数而阻塞，此时，读操作会返回FIFO中现有的数据量。

写规则：
1,如果一个进程为了向FIFO中写入数据而阻塞打开FIFO，那么称该进程内的写操作为设置了阻塞标志的写操作。
2,/当要写入的数据量 不大于 PIPE_BUF时，Linux将保证写入的原子性;当要写入的数据量 大于 PIPE_BUF时，Linux将不再保证写入的原子性。


/**其实阻塞状态下的有名管道可以理解为同步通讯，只有读写进程同时打开通道才能传输，否则不能传输*/
与普通文件不同的是阻塞问题  
　　•普通文件的读写时不会出现阻塞问题
　　•在管道的读写中却有阻塞的可能，
　　•非阻塞标志：在open()函数中设定为O_NONBLOCK
 
阻塞打开与非阻塞打开 
对于读进程
　　•若该管道是阻塞打开，且当前FIFO内没有数据，则对读进程而言将一直阻塞到有数据写入,有数据就直接读
　　•若该管道是非阻塞打开，则不论FIFO内是否有数据，读进程都会立即执行读操作。即如果FIFO内没有数据，则读函数将立刻返回0
对于写进程
　　•若该管道是阻塞打开，则写操作将一直阻塞到有进程要读数据，才能写
　　•若该管道是非阻塞打开而不能写入全部数据，则读操作进行部分写入或者调用失败
		
		
	阻塞模式读写进程，只有同时运行才能够传输数据
	//读进程
	#include <unistd.h>
	#include <stdlib.h>
	#include <stdio.h>
	#include <fcntl.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <limits.h>
	#include <string.h>

	int main()
	{
		char *name="my_fifo";
		char buf[100];
		int rf;
		rf=open(name,O_RDONLY);
		int res;
		res=read(rf,buf,sizeof(buf));
		if(res>0){
			printf("%d\n",res);
		}
		exit(EXIT_SUCCESS);
	}


	//写进程
	#include <unistd.h>
	#include <stdlib.h>
	#include <stdio.h>
	#include <fcntl.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <limits.h>
	#include <string.h>

	int main()
	{
		char *name="my_fifo";
		char buf[100]="123455";
		mkfifo(name,0777);
		int wf;
		wf=open(name,O_WRONLY)
		int res;
		res=write(wf,buf,sizeof(buf));
		if(res>0){
			printf("%d\n",res);
		}
		exit(EXIT_FAILURE);
	}
