
//位运算技巧

//左移和右移规则
对左移而言，移动正数和负数规则是相同的；对于右移而言，则有些差别，正数在最高位补0，负数在最高位补1。 
对于一个16位的正数：0000 0000 0000 0101，左移一位是0000 0000 0000 1010，右移一位是0000 0000 0000 0010 
对于一个16位的负数：1000 0000 0000 0101，左移一位是0000 0000 0000 1010，右移一位是1100 0000 0000 0010

//位运算技巧
1.两个数异或 两次得到的还是原来的数
2.不使用中间变量交换两个整数
x ^= y    // x = x ^ y
y ^= x    // y = y ^ (x ^ y) = x    ====>   y == x
x ^= y    // x = (x ^ y) ^ x = y

3.n & (n - 1) 将整数 n 的最后一位为1的位变成0 ，也可以判断n是否为2的幂
求一个数字的二进制中 1 的个数
int OneCount(int n)
{
    int count = 0;
    while(n)
    {
        n = n & (n-1);//每执行一次，n的最后一个为1的位变成0，如：110执行一次变成100,101执行一次变成100；
        count++;
    }
    return count;
}

判断一个数是不是2的幂

int fun(int n)
{
    n = n & (n-1);  // 返回值为 0 表示是2的幂，返回值非零表示不是2的幂，如果是2的幂，那这个数的二进制只有最高位是1，所以执行一次就变成0
    return n;
}

判断一个数是不是2的幂
				/*是4的幂的数一定是2的幂，因此先判断是不是2的幂，2的幂保证了这个数只有1个1，就看这个1在什么位置
				  2的幂中 1 在奇数位上的是4的幂，与0x55555555按位与，如果是4的幂，那1在奇数位上，如0100，10000，和奇数位的5(0101)，如果非零，就是，是0就不是
				  如果奇数位上有数则是4的幂
				*/
int fun(int n)
{
    if((n & (n - 1)) == 0)  //2的幂保证了这个数只有1个1，就看这个1在什么位置
    {
        return (n & 0x55555555);  //返回0表示不是4的幂，返回非0表示是4的幂，4的幂的1在奇数位上
    }
    return 0;
}

输入两个整数m和n，计算需要改变多少位能使m变成n

				//将m和n按位异或，相同的位为0，不同的位为1，然后 统计1的个数
int fun(int m, int n)
{
	m = m ^ n;
	int count = 0;
	while(m)
	{
	m = m & (m - 1);
	count++;
	}
	return count;
}


4.n & (~n + 1)    提取出整数n最后一位为1的数 ,如：n=1100,返回0100；n=1001，返回0001；
求一个数字的二进制中 1 的个数
int fun(int n)
{
    int count = 0;
    while(n)
    {
        n -= n & (~n + 1);//n减去最后一个1，直到减完
        ++count;
    }
    return count;
}

5.完成整数相加

int Add(int num1, int num2)
{
	int sum, carry;

	do{
		sum = num1 ^ num2;     //将两个数异或，模拟加法中相加不进位的结果
		carry = (num1 & num2) << 1;  //只考虑进位的情况
		num1 = sum;
		num2 = carry;
	}while(num2 != 0);    //将结果相加的过程就重复上述过程，直到进位为0

 return sum;

}


6.判断 int 型变量  n 是奇数还是偶数 
a & 1 = 0  // 偶数 
a & 1 = 1  // 奇数 


7.位变换操作
去掉最后一位 ：x >> 1
在最后加一个0： x << 1
在最后加一个1：(x << 1) | 1
把最后一位变成1：x | 1
把最后一位变成0：(x | 1) - 1
最后一位取反 ：x ^ 1
把右数第k位置1：1 << (k-1)
把右数第k位清0 ：x & ~(1 << (k-1))
右数第k位取反：x ^ (1 << (k-1))
取末三位 ：x & 7
取末k位：x & ((1 << k)-1)
取右数第k位：(x >> (k-1)) & 1
把右边连续的1变成0：x & (x+1)
把右起第一个0变成1：x | (x+1)
把右边连续的0变成1：x | (x-1)

取第k位：( x >> (sizeof()-k) ) & 1
第k位清0：x & ~( 1 << (sizeof()-k) )
第k位置1：x | ( 1 << (sizeof()-k) )


8.去整数平均值
int average(int x, int y) //返回X,Y 的平均值 
{ 
    return (x & y) + ((x^y) >> 1); 
}  


9、计算绝对值 
int abs( int x ) 
{ 
    int y ; 
    y = x >> 31 ; 
    return (x^y) - y ; //or: (x+y)^y 
} 
x的相反数表示为  ~x+1


10、取模运算 ==> 位运算 (在不产生溢出的情况下) 
a % (2^n) ====> a & (2^n - 1)
eg : a % 2 == a & 1     
	 a % 4 == a & 3


11、乘法运算 ==> 位运算 (在不产生溢出的情况下) 
a * (2^n) ====> a << n 
eg : a * 2  ==  a << 1     
	 a * 4  ==  a << 2     
	 a * 8  ==  a << 8


12、除法运算 ==> 位运算 (在不产生溢出的情况下) 
a / (2^n) ===>  a >> n  
eg : a / 2 == a >> 1      
	 a / 4 == a >> 2     
	 a / 8 == a >> 3
