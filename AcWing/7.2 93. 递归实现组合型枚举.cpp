//7.2 93. 递归实现组合型枚举 

从 1~n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。
输入格式
两个整数 n,m,在同一行用空格隔开。
输出格式
按照从小到大的顺序输出所有方案，每行1个。
首先，同一行内的数升序排列，相邻两个数用一个空格隔开。
其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如1 3 5 7排在1 3 6 8前面）。
数据范围

n>0
0≤m≤n
n+(n−m)≤25

输入样例：
5 3
输出样例：
1 2 3 
1 2 4 
1 2 5 
1 3 4 
1 3 5 
1 4 5 
2 3 4 
2 3 5 
2 4 5 
3 4 5 
思考题：如果要求使用非递归方法，该怎么做呢？



#include<iostream>
#include<algorithm>

using namespace std;
const int N=30;

int n,m;
bool a[N];

void dfs(int k,int t){  //t：计数，已经有多少个数选上了
    
    if(t==m){
        for(int i=1;i<=n;i++)
            if(a[i])
                cout<<i<<" ";
        cout<<endl;
        return;
    }
    if(k>n)return;  //注意这个判断只能在上一个判断后面，因为当判断玩最后一个数之后，递归进来k>n,但是如果这个在前，恰好t=m，那这一组就不能得到输出
    
    a[k]=true;
    dfs(k+1,t+1);//因为是从小到大排序，所以优先递归选择的，因为是从小往大选，上来就选的是小的，所以就先输出
    a[k]=false;
    dfs(k+1,t);
    
    
}


int main(){
    cin>>n>>m;
    dfs(1,0);
    return 0;
}