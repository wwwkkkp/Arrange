
//17.2.587. 吃蛋糕 

惠特利在参加世界上最好的派对：它有着无数的蛋糕！ 
每个蛋糕都呈具有整数边长（cm）的正方形形状。 
派对上有无限多个边长为任意整数的蛋糕。 
蛋糕都有相同的高度，所以我们只考虑它们的面积。
惠特利决定吃一个或多个蛋糕，使其总面积恰好为N cm2
。 
你能帮他计算一下他最少需要吃掉多少个蛋糕吗？
输入格式
第一行包含整数T，表示共有T组测试数据。
每组数据占一行，包含一个整数N，为惠特利想吃掉的蛋糕的总面积。
输出格式
每组数据输出一个结果，每个结果占一行。
结果表示为“Case #x: y”，其中x是组别编号（从1开始），y是惠特利最少需要吃掉的蛋糕数量。
数据范围
1≤T≤100

1≤N≤10000
输入样例：
3
3
4
5
输出样例：
Case #1: 3
Case #2: 1
Case #3: 2
样例解释
在样例＃1中，唯一可行的策略是惠特利吃三个边长为1的蛋糕。
在样例＃2中，惠特利可以吃一个边长为2的蛋糕。
在样例＃3中，最好的策略是惠特利吃一个边长为2的蛋糕和一个边长为1的蛋糕。


//全局背包问题，f[i][j]=min(f[i-1][j],f[i][j-a[i]]+1); 可以转换成1维，f[j]=min(f[j],f[j-a[i]]+1);
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N=110,M=10010;

int n,t;
int f[N][M];

int main(){
    cin>>t;
    for(int c=1;c<=t;c++){
        cin>>n;
        memset(f,0x3f3f3f,sizeof f);  //当求最小值的时候，最好先设置成无穷大，不然会被f的初始值影响
        f[0][0]=0;        		  //初始情况
        for(int i=1;i*i<=n;i++){  //注意初始值，这个是比较固定的
            for(int j=0;j<=n;j++){
                f[i][j]=f[i-1][j];
                if(j>=i*i)
                    f[i][j]=min(f[i][j],f[i][j-i*i]+1);
            }
        }
        int res=1e9;
        for(int i=1;i*i<=n;i++)res=min(res,f[i][n]);
        printf("Case #%d: %d\n",c,res);
    }
}
