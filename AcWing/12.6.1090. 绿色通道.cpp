

//12.6.1090. 绿色通道

高二数学《绿色通道》总共有 n 道题目要抄，编号 1,2,…,n，抄第 i 题要花 ai分钟。
小 Y 决定只用不超过 t
分钟抄这个，因此必然有空着的题。
每道题要么不写，要么抄完，不能写一半。
下标连续的一些空题称为一个空题段，它的长度就是所包含的题目数。
这样应付自然会引起马老师的愤怒，最长的空题段越长，马老师越生气。
现在，小 Y 想知道他在这 t
分钟内写哪些题，才能够尽量减轻马老师的怒火。
由于小 Y 很聪明，你只要告诉他最长的空题段至少有多长就可以了，不需输出方案。
输入样例
17 11
6 4 5 2 5 3 4 5 2 3 4 5 2 3 6 3 5


输出样例
3


//二分+单调栈：

#include<iostream>
#include<algorithm>
using namespace std;

const int N = 50010;

int n, m;
int a[N];
int q[N], f[N];

bool check(int t) {
	int hh = 0, tt = 0;
	for (int i = 1; i <= n; i++) {
		if (q[hh] < i - t - 1)hh++;//注意这里是i-t-1，当求第i个题写作业时，前t个题都可以是空的，所以可以从i-t-1这个位置开始求
		f[i] = f[q[hh]] + a[i];
		while (hh <= tt && f[q[tt]] >= f[i])tt--;//维护单调栈，注意这里是大于等于，因为是单调栈，所以必须严格大于前面的数
		q[++tt] = i;
	}
	int res = INT_MAX;
	for (int i = n; i >= n - t; i--) {//这里是选择从n-t到t的数中最小的，当选择了n-t是，后面的t个位置都可以不用写了
		res = min(res, f[i]);
	}
	return res <= m;//如果小于等于要求时间，说明最大空题段太大了，需要减小，否则增大
}

int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	int le = 0, ri = n; //最长空题段的长度
	while (le < ri) {
		int mid = le + ri >> 1;
		if (check(mid))ri = mid; //当最长空题段的长度是mid时，花费最少的时间小于m,说明空题段太大了，应该减少，当大于m时，说明空题段太小了，应该增大，因为求的是最小时间，所以耗时应该尽可能小，所以等于m的时候，要让ri=mid；
		else le = mid + 1;
	}
	cout << ri << endl;
	return 0;
}

//关于二分：当求 最大值最小 时就可以用二分法，这道题求的就是 空题段最大的同时耗时最小