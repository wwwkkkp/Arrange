


//17.5.623. 投票 

A和B是在某次选举中竞争的两名候选人。 
我们从民意调查中得知，共有N个选民支持A，M个选民支持B.
我们也知道N大于M，所以A会获胜。
选民将一个一个的进行投票，投票的顺序是从所有的共计(M+N)!个可能的顺序中随机挑选出来的。
在每一个选民的投票完成后，投票站工作人员都会实时更新投票结果，并记录处于领先位置的候选人。
请问A从投票开始至投票结束能够一直保持票数领先的概率是多少？
输入格式
第一行包含整数T，表示共有T组测试数据。
每组数据占一行，包含两个整数N和M。
输出格式
每组数据输出一个结果，每个结果占一行。
结果表示为“Case #x: y”，其中x是组别编号（从1开始），y是A能始终保持票数领先的概率。
如果y在正确答案的10−6的绝对或相对误差范围内，则y将被认为是正确的。

数据范围
1≤T≤100
0≤M<N≤2000

输入样例：
2
2 1
1 0
输出样例：
Case #1: 0.33333333
Case #2: 1.00000000
样例解释
在样例＃1中，有3个选民，其中两个支持A，称其为A1,A2，一个支持B。
共有6种可能的投票顺序分别为(A1,A2,B), (A2,A1,B), (A1,B,A2), (A2,B,A1), (B,A1,A2), (B,A2,A1)，其中只有(A1,A2,B)和(A2,A1,B)满足三轮投票过后A始终保持领先。
所以答案是2/6 = 0.333333 ......
在样例＃2中，只有1个选民，并且该选民支持A。所以只有一轮，A一定会获胜。



//我为人人
#include<iostream>
#include<cstring>

using namespace std;

const int N=2010;
double f[N][N];

int n,m,t;

int main(){
    cin>>t;
    for(int c=1;c<=t;c++){
        cin>>n>>m;
        memset(f,0,sizeof f);
        f[1][0]=(double)n/(n+m);
        
        for(int i=1;i<=n;i++)
            for(int j=0;j<i;j++){  //当在f[i][j]的时候，算出 f[i+1][j] 和 f[i][j+1] 
                f[i+1][j]+=f[i][j]*(double)(n-i)/(n+m-i-j);
                f[i][j+1]+=f[i][j]*(double)(m-j)/(n+m-i-j);
            }
        printf("Case #%d: %.8f\n",c,f[n][m]);
    }
    return 0;
}