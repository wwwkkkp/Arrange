//34.1537. 排列 


给定一个长度为 n的可包含重复数字的序列，请你求出其所有不重复的全排列。
输入格式
第一行包含整数 n。
第二行包含 n个整数。
输出格式
输出所有的不同排列，每种排列占一行。
在确定每种排列的输出顺序时，第一个数较小的先输出，第一个数相同时，第二个数较小的先输出，以此类推。
数据范围1≤n≤9,数组中包含的元素的取值范围 [1,9]

输入样例：
3
1 1 2
输出样例：
1 1 2
1 2 1
2 1 1


//有重复数字的全排列，不能重复

#include<iostream>
#include<algorithm>

using namespace std;

const int N=12;
int n;
int a[N],b[N];
bool st[N];

void dfs(int k){
    if(k==n){
        for(int i=0;i<n;i++)
            cout<<b[i]<<" ";
        cout<<endl;
        return ;
    }
    for(int i=0;i<n;i++){
        if(!st[i]){
            st[i]=true;
            b[k]=a[i];
            dfs(k+1);
            st[i]=false;
            while(i+1<n&&a[i]==a[i+1])i++;  //注意这里一个技巧，要保证输出没有重复，就要保证相同的数的相对位置是不变的，当选择某一个数之后，他后面和他一样的数就不能选了，不然相对位置就会发生变化，
			//比如，1 1 2  2 ,第一个1和第二个1的相对位置不能变，所以当某个位置选择了第一个1之后，该位置就不能是第二个1，因为如果选了第二个1，那第一个1就会被放在第二个1的后面，相对位置改变
        }
    }
}
//这道题很奇怪，如果数组是从0位开始存储就可以通关，如果是从1位开始存储就超时
int main(){
    cin>>n;
    for(int i=0;i<n;i++)cin>>a[i];
    sort(a,a+n);
    dfs(0);
    return 0;
    
}
