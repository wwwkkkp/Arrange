//19.1490. 最长上升子串 

/*
给出一个长度为 n的由正整数构成的序列，你需要从中删除一个正整数，很显然你有很多种删除方式，你需要对删除这个正整数以后的序列求其最长上升子串，请问在所有删除方案中，最长的上升子串长度是多少。
这里给出最长上升子串的定义：即对于序列中连续的若干个正整数，满足 ai+1>ai，则称这连续的若干个整数构成的子串为上升子串，在所有的上升子串中，长度最长的称为最长上升子串。

输入格式
输入第一行仅包含一个正整数 n，表示给出的序列的长度。
接下来一行有 n个正整数，即这个序列，中间用空格隔开。

输出格式
输出仅包含一个正整数，即删除一个数字之后的最长上升子串长度。
数据范围 1≤n≤10^5,1≤ai≤10^5

输入样例：
5
2 1 3 2 5
输出样例：
3
*/

//

#include<iostream>
#include<algorithm>

const int N=1e5+10;

int n;
int a[N] f[N],g[N];  //f[i]:以第i个数为结尾的最长子串，g[i]:以第i个数为开始的最长子串

int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	f[1]=1;
	g[n]=1;
	for(int i=2;i<=n;i++)
		if(a[i]>a[i-1])
			f[i]=f[i-1]+1;
		else
			f[i]=1;
	for(int i=n-1;i>0;i--){
		if(a[i]<a[i+1])
			g[i]=g[i+1]+1;
		else 
			g[i]=1;
	}
	int res=1;
	for(int i=1;i<=n;i++){
		if(a[i-1]<a[i+1])
			res=max(res,f[i-1]+g[i+1]); //如果删除的那个数左边和右边能够拼起来
		else 
			res=max(res,max(f[i-1],g[i+1]));  //如果不能拼起来，取左右最大值，因为遍历了所有的数，所以是最终结果，无论删除的数是否在最长子串中
	}
	cout<<res<<endl;
	return 0;
}
