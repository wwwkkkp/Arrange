
//15.4.1274. 奶牛排队 

每天，农夫 John 的 N头牛总是按同一序列排队。
有一天，John 决定让一些牛玩一场飞盘比赛。
他准备找一群在队列中位置连续的牛来进行比赛，但是为了避免水平悬殊，牛的身高不应该相差太大。
John 准备了Q个可能的牛的选择和所有牛的身高。他想知道每一组里面最高和最矮的牛的身高差别。

输入格式
第一行包含两个整数 N,Q。第二至第 N+1行，第 i行是第 i头牛的身高 hi；
第 N+2至第 N+Q+1行，每行两个整数 A和 B，表示从A到 B的所有牛。
牛的编号从1到 N。
输出格式
第一至第 
Q
行，每行一个整数，表示对于询问的回答（即最高和最矮的牛的身高差）。
数据范围
1≤N≤5×104
1≤Q≤1.8×105
1≤hi≤106
1≤A≤B≤N
输入样例：
6 3
1
7
3
4
2
5
1 5
4 6
2 2
输出样例：
6
3
0


//简单的说就是寻找任意一个区间中的最大值和最小值，
//方法：ST树


#include<iostream>
#include<algorithm>

using namespace std;

const int N=50010;

int n,q;
int a[N],b[N];
int f[N][17],g[N][17];//f:起点是i，长度是2^j-1的区间中的最大值，g是对应的最小值   为什么是这个区间，在[a,b]区间中找最大值，k=b-a；寻找小于k的最大的2的整次幂，即2^t>=k/2;这样，以a为起点，长度是2^t，以b为终点，长度是2^t,这两个区间就覆盖了[a,b]只需要求这两个区间的最大值和最小值即可。

int main(){
    cin>>n>>q;
    for(int i=1;i<=n;i++)cin>>a[i];
    int i=0;
    for(;1<<i<=n*2;i++){
        b[i]=(1<<i);
    }
    for(int j=0;1<<j<=n;j++){  //从小区间长度开始计算，由小区间长度推大区间长度，
        for(int k=1;k+(1<<j)-1<=n;k++){
            if(!j)f[k][0]=g[k][0]=a[k];//j等于0的时候，区间长度就是0，区间就起始树一个数，那最大值最小值都是本身
            else{
                f[k][j]=max(f[k][j-1],f[k+(1<<(j-1))][j-1]);//最大值
                g[k][j]=min(g[k][j-1],g[k+(1<<(j-1))][j-1]);//最小值
            }
        }
    }

    
    while(q--){
        int x,y;
        cin>>x>>y;
        int k=y-x;
        int t=0;
        while(b[t]<=k)t++;
        if(t)t--;  //寻找小于k的最大的2的整次幂
 
        int maxh=max(f[x][t],f[y-(1<<t)+1][t]);
        int minh=min(g[x][t],g[y-(1<<t)+1][t]);
        cout<<maxh-minh<<endl;
    }
    return 0;
}