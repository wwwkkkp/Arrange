//21.1491. 圆桌座位 


N个人围坐一圈，有 M对朋友关系。
第 i对朋友关系是指，编号是ai的人和编号是 bi的人是朋友。

现在要给他们安排座位，要求所有相邻的人不能是朋友。
问共有多少种方案？

如果两个方案只有旋转角度不同，则我们将其视为一种方案。
输入格式
第一行包含两个整数 N,M。接下来 M行，每行包含一对 ai,bi。
输出格式
输出一个数，表示总方案数。

数据范围3≤N≤10,0≤M≤N(N−1)2,1≤ai<bi≤N,(ai,bi)≠(aj,bj),所有输入均为整数。

输入样例1：
4 1
1 2
输出样例1：
2
输入样例2：
10 5
1 2
3 4
5 6
7 8
9 10
输出样例2：
112512


//暴力DFS
1,先用数组把关系存起来，使第一个数是1，固定下来
2,遍历所有的数，看哪些数可以放在旁边，然后计算第三个位置，以此列推
3,截止条件：如果最后一个数和第一个数没有关系，算一种方案，如果有关系，返回0

#include<iostream>
#include<algorithm>

using namespace std;
const int N=11,M=11;
int n,m;
bool f[M][M]={0};
int v[N]={0};  //第i个位置是否被访问过
int st[N];   //第 i 个位置填的数

int dfs(int j){  //第j个位置可选择的数量
	if(j==n+1){
		if(f[st[j-1]][1]==1)
			return 0;
		else{
		    return 1;
		}
			
	}
	int res=0;
	for(int i=2;i<=n;i++){
		if(v[i]==0&&f[i][st[j-1]]!=1){//i没有被使用，并和上一个数没有朋友关系
			st[j]=i;
			v[i]=1;
			res+=dfs(j+1);
			v[i]=0;  //注意回溯
		}
	}
	return res;
}

int main(){
	cin>>n>>m;
	for(int i=0;i<m;i++){
		int a,b;
		cin>>a>>b;
		f[a][b]=1;
		f[b][a]=1;
	}
	st[1]=1;   //把第一个数固定下来，避免重复
	v[1]=1;
	cout<<dfs(2)<<endl;
	
	return 0;
}
