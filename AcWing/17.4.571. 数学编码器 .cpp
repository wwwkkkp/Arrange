//17.4.571. 数学编码器 

Math教授正致力于一个秘密项目，并面临着一个挑战，即需要以最有效的方式将数字列表编码为单个数字。 
经过大量研究，Math教授找到了一个可以最好地编码数字的3步过程：
第一步是找到数字列表的所有可能的非空子集，然后，对于每个子集，找到该子集中最大和最小数字之间的差（即，最大减去最小值）。 请注意，如果子集中只有一个数字，则该子集中的最大和最小数字都为这个数字。 完整集本身也被视为子集之一。
然后将所有差值相加以获得最终编码数。
由于最终结果可能很大，因此输出对1000000007取模后的数字。
现在给定一个数字列表，请你帮助教授计算最终的编码数字是多少。
注意：
子集中可以包含相同元素，例如集合{2, 2, 2}一共有7个非空子集。

输入格式
第一行包含整数T，表示共有T组测试数据。
每组数据，第一行包含整数N，表示数字列表中的数字的个数。
第二行包含N个整数Ki，按非递减顺序排序，表示数字列表。
输出格式
每组数据输出一个结果，每个结果占一行。
结果表示为“Case #x: y”，其中x为组别编号（从1开始），y为最终编码数字对1000000007取模后的结果。
数据范围
1≤T≤25
1≤Ki≤10000
1≤N≤10000
输入样例：
2
4
3 6 7 9
3
2 2 2
输出样例：
Case #1: 44
Case #2: 0
样例解释
样例#1，找到所有子集并获取最大和最小数字之间的差值，如下所示：
[3]，最大-最小= 3 - 3 = 0。
[6]，最大-最小= 6 - 6 = 0。
[7]，最大-最小= 7 - 7 = 0。
[9]，最大-最小= 9 - 9 = 0。
[3,6]，最大-最小= 6 - 3 = 3。
[3,7]，最大-最小= 7 - 3 = 4。
[3,9]，最大-最小= 9 - 3 = 6。
[6,7]，最大-最小= 7 - 6 = 1。
[6,9]，最大-最小= 9 - 6 = 3。
[7,9]，最大-最小= 9 - 7 = 2。
[3,6,7]，最大-最小= 7 - 3 = 4。
[3,6,9]，最大-最小= 9 - 3 = 6。
[3,7,9]，最大-最小= 9 - 3 = 6。
[6,7,9]，最大-最小= 9 - 6 = 3。
[3,6,7,9]，最大-最小= 9 - 3 = 6。
找出上一步计算的差异总和：
3 + 4+ 6 +1 + 3+ 2 + 4+6 + 6+3 + 6 = 44。
对1000000007取模后的结果仍为 44。


///简单的说就是一个数组中的所有子集的最大值和最小值之差的和

//由于数组最多有10000个数，所以子集的数目很大，不能直接算，
//有一个巧办法：计算每个数作为最大值的时候的次数 和 每个数作为最小值的时候的次数，次数之差*这数=所有包含这个数的计算的结果，遍历一遍数组，就是最终结果
#include<iostream>

using namespace std;
typedef long long ll;
const int N=10010,M=1000000007;

int t,n;
int f[N];
ll  a[N];

int main(){
    cin>>t;
    for(int c=1;c<=t;c++){
        cin>>n;
        f[0]=1;
        for(int i=1;i<n;i++)f[i]=(f[i-1]*2)%M;
        for(int i=0;i<n;i++)cin>>a[i];
        ll res=0;
        for(int i=0;i<n;i++){
            res=(res+a[i]*(f[i] - f[n-1-i]))%M; //a[i]*作为最大值次数-作为最小值次数
        }
        printf("Case #%d: %lld\n",c,res);
    }
}
