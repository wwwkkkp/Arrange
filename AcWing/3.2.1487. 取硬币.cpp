//14.1487. 取硬币 

/*
现在有 n1+n2 种面值的硬币，其中前 n1种为普通币，可以取任意枚，后 n2种为纪念币，每种最多只能取 1枚，每种硬币有一个面值，问能用多少种方法拼出 m的面值？
输入格式
第一行包含三个整数 n1,n2,m，分别表示普通币种类数，纪念币种类数和目标面值；
第二行 n1 个整数，第 i种普通币的面值 a[i]。保证 a[i]为严格升序；
第三行n2个整数，第 i中纪念币的面试 b[i]。保证 b[i]为严格升序。

输出格式
共一行，包含一个整数 x，表示方法总数对 10^9+7取模后的结果。注意，不要忘记取模。

数据范围
对于 30%的数据，保证1≤n1+n2≤10,1≤m≤100,1≤a[i]≤100,1≤b[i]≤100.对于 100%的数据，保证 1≤n1+n2≤100,1≤m≤100000,1≤a[i]≤100000,1≤b[i]≤100000。
输入样例：
3 1 5
1 2 3
1
输出样例：
9
*/


//背包问题有 0-1背包问题，全局背包问题，就是从一堆数中拿掉一个数以后，还能不能继续拿这个数，不能就是0-1问题，能就是全局问题
//这个题是 全局背包 + 0-1背包问题


#include<iostream>
#include<algorithm>

using namespace std;
const int N=110,M=100010,MOD=1e9+7;

int n1,n2,m;
int p[N],g[N];
int f[N][M];

int main(){
	cin>>n1>>n2>>m;
	for(int i=1;i<=n1;i++){
		cin>>p[i];
	}
	for(int i=1;i<=n2;i++)
		cin>>g[i];
	for(int i=1;i<=n1;i++)
		f[i][0]=1;      //当等于0的时候，只有1种方法
		
	for(int i=1;i<=n1;i++){
		for(int j=1;j<=m;j++){
			f[i][j]=f[i-1][j];
			if(j>=p[i])f[i][j]=(f[i][j]+f[i][j-p[i]])%MOD;
		}
	}
	
    for(int k=1;k<=n2;k++){
        for(int j=m;j>=g[k];j--)
	        f[n1][j]=(f[n1][j]+f[n1][j-g[k]])%MOD;
    }
   
	
	cout<<f[n1][m]<<endl;
	return 0;
}


//全局背包：
f[i][j]:前i个数中，选择一堆数相加等于j的集合 的个数，数可以重复取
f[i][j]=f[i-1][j]+f[i-1][j-p[i]]+f[i-1][j-p[i]*2]+....;
// f[i-1][j]:当没有选择第i个数的时候，f[i-1][j-p[i]]：选择了一次第i个数，f[i-1][j-p[i]*2]：选择了两次，条件j-p[i]>=0;
f[i][j-p[i]]=f[i-1][j-p[i]]+f[i-1][j-p[i]*2]+....; 恰好把上式中的后面部分替换掉，所以  f[i][j]=f[i-1][j]+f[i][j-p[i]];
 
 
//注意：上式可以简化成 f[j]=f[j]+f[j-p[i]] ，全局背包问题是正向迭代的，即 for(int j=1;j<=m;j++)，因为随着j的增大，f[j-p[i]] 是经过更新的，


//0-1背包问题：前i个数中，选择一堆数相加等于j的集合 的个数，数不可以重复取
f[i][j]=f[i-1][j]+f[i-1][j-p[i]]; // 也是选择了第i个数和没选择第i个数


//注意：上式可以简化成   f[j]=f[j]+f[j-p[i]];  但是，这样改必须要从大到小遍历，如果是从小到大遍历，如j<=10,p[i]=2,先改变了f[2]+=f[0],f[4]+=f[2],后式的f[2]已经是修改过了，所以错误







