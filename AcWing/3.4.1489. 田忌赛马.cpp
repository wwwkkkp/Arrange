//16.1489. 田忌赛马 

这是中国历史上的一个著名故事。
大约 2300年前，田忌是齐国的一位将军，他喜欢与国王等人赛马。
田忌和国王都有三匹不同等级的马----下马、中马、上马。
规则是一场比赛要进行三个回合，每匹马进行一回合的较量，单回合的获胜者可以从失败者那里得到 200银元。
比赛的时候，国王总是用自己的上马对田忌的上马，中马对中马，下马对下马。
由于国王每个等级的马都比田忌的马强一些，所以比赛了几次，田忌都失败了，每次国王都能从田忌那里拿走 600银元。
田忌对此深感不满，直到他遇到了著名的军事家孙膑，利用孙膑给他出的主意，田忌终于在与国王的赛马中取得了胜利，拿走了国王的 200银元。
其实胜利的方法非常简单，他用下马对战国王的上马，上马对战国王的中马，中马对战国王的下马，这样虽然第一回合输了，但是后两回合都胜了，最终两胜一负，取得了比赛胜利。
 
如果田忌活在如今，那么他可能会嘲笑自己当初的愚蠢。
重要的是，如果他现在正参加 ACM 竞赛，他可能会发现赛马问题可以简单地看作是在二分图中找到最大匹配项。
在一侧画田忌的马，在另一侧画国王的马，只要田忌的一匹马能够击败国王的一匹马，我们就在这两匹马之间画一条边。
然后，赢尽可能多的回合，就变成了在这个二分图中找到最大匹配。
如果存在平局，问题会变得更加复杂，他需要为所有可能的边分配权重 0、1或 −1，并找到最大加权的完美匹配…

然而，赛马问题其实是二分图匹配的一种非常特殊的情况。
该图由马的速度决定，速度快的总是能击败速度慢的。
这种情况下，加权二分图匹配算法就显得大材小用了。
在这个问题中，你需要编写一个程序，来解决这一特殊的匹配问题。

输入格式
输入包含最多 50组测试数据。
每组数据第一行包含一个整数 n，表示一方马的数量。
第二行包含 n个整数，是田忌的马的速度。
第三行包含 n个整数，是国王的马的速度。
输入的最后一行为 0，表示输入结束。

输出格式
每组数据输出一个占一行的整数，表示田忌最多可以获得多少银元。
数据范围1≤n≤1000马的速度不超过 1000。
输入样例：
3
92 83 71
95 87 74
2
20 20
20 20
2
20 19
22 18
0
输出样例：
200
0
0





//其实这道题求的就是两堆马中，一堆能够净胜的最多的安排策略



#include<iostream>
#include<algorithm>

using namespace std;
const int N=1010;

int m;
int f[N],g[N];

int juice(int a,int b){
    if(f[a]>g[b])return 1;
    else if(f[a]<g[b]) return -1;
    else return 0;
}


int main(){
    
	while(cin>>m,m!=0){
		for(int i=0;i<m;i++) cin>>f[i];
		for(int i=0;i<m;i++) cin>>g[i];
		
		sort(f,f+m,greater<int>());
		sort(g,g+m,greater<int>());
		
		int ff=0,fs=m-1,gf=0,gs=m-1;
		
		int res=0;
		while(ff<=fs){
			if(f[fs]>g[gs]) {gs--;fs--;res++;}
			else if(f[fs]<g[gs]){ 				    
				    res+=juice(fs,gf);fs--;gf++;
			}
			else{
				if(f[ff]>g[gf]) {res++;ff++;gf++;}
				else if(f[ff]<=g[gf]) {
                    res+=juice(fs,gf);fs--;gf++;
				}
			}
			//cout<<ff<<" "<<fs<<" "<<gf<<" "<<gs<<endl;
		}
		cout<<res*200<<endl;
	}
	return 0;
}


//
田忌的马用f表示，f[0]是最快的马，f[m-1]是最慢的马
齐王的马用g表示，g[0]是最快的马，g[m-1]是最慢的马

从最慢的马开始分析

齐王最快的马f2，齐王最慢的马s2，田忌最快的马f1，田忌最慢的马s1,

如果s1<s2,就让s1和f2比较，反正都是输，选对方一个最快的
如果s1>s2，就让s1和s2比较，赢一局，
如果s1=s2，分三种情况：
	1.f1>f2，让f1和f2比较，赢一局，
	2.f1<f2，让s1和f2比较，反正都是输，选对方一个最快的
	3.f1=f2，就让s1和f2比较，原因如下：
		选择田忌的某匹马(不是最慢的)，假设这个马是x,x可能等于f1
		两种情况：
			x!=f1:1.f2和x比，s1和s2比，因为f2>x，负一场
				  2.f2和s1比，x和s2比，因为f2>s1，x>s2，平，（如果f2=s1，也是平局）
			x=f1: f1=f2,s1=s2,怎么安排都是平局，
			
			综上，如果f1=f2,s1=s2，f2和s1比，因为不知道f2是否大于s1(可能一样大)，所以要判断一下谁获胜
		

