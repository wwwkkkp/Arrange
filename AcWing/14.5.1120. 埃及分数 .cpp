
//14.5.1120. 埃及分数 

在古埃及，人们使用单位分数的和（形如 1a的，a 是自然数）表示一切有理数。
如：
2/3=1/2+1/6，但不允许 2/3=1/3+1/3，因为加数中有相同的。
对于一个分数 a/b，表示方法有很多种，但是哪种最好呢？
首先，加数少的比加数多的好，其次，加数个数相同的，最小的分数越大越好。如：

19/45=1/3+1/12+1/180
19/45=1/3+1/15+1/45
19/45=1/3+1/18+1/30
19/45=1/4+1/6+1/180
19/45=1/5+1/6+1/18

最好的是最后一种，因为 1/18比 1/180，1/45，1/30，1/180 都大。
注意，可能有多个最优解。如：
59/211=1/4+1/36+1/633+1/3798
59/211=1/6+1/9+1/633+1/3798
由于方法一与方法二中，最小的分数相同，因此二者均是最优解。
给出 a,b，编程计算最好的表达方式。保证最优解满足：最小的分数 ≥1/10^7
输入格式
一行两个整数，分别为 a和 b的值。

输出格式
输出若干个数，自小到大排列，依次是单位分数的分母。
数据范围
0<a<b<1000
输入样例：
19 45
输出样例：
5 6 18



//这道题其实还是枚举，当分数为a/b的的时候，最大的那个分数的取值范围为 b/a的上取整 到 b*t/a的下取整，t是当前分数能分成几分，证明见下:

#include<iostream>
#include<vector>

using namespace std;
typedef long long ll;
vector<ll>pre,d;


int g(ll a,ll b){   //最大公约数的公式，记住
    return b?g(b,a%b):a;
}

void dfs(ll a,ll b,int last,int t){
   if(!t){
       if(!a&&(!pre.size()||(pre.size()<=d.size()&&pre.back()>d.back()))){
           pre=d;
           return ;
       }
       return ;
   } 
   int k=g(a,b); //最大公约数
   a/=k;
   b/=k;
   
   ll p=b/a;

   for(ll i=(p*a==b)?p:p+1;i<=b*t/a;i++){
       if(i>last){
            d.push_back(i);
            dfs(a*i-b,b*i,i,t-1);
            d.pop_back();
       }
   }
   
}

int main(){
    int a,b;
    cin>>a>>b;
    int t=1;
    while(1){
        dfs(a,b,-1,t);//依次选择当分成t份的时候的大小
        if(pre.size())break;
        t++;
    }
    for(int i=0;i<pre.size();i++){
        cout<<pre[i]<<' ';
    }
    cout<<endl;
}



//首先保证：a/b-1/x>=0; => x>=b/a;
//然后，a/b-1/x1-1/x2...=0；一共有t个x,且x1最小，a/b-t/x1<=0; => x1<=b*t1/a;