
//11.4.415. 栈 
栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。
栈有两种最重要的操作，即pop（从栈顶弹出一个元素）和push（将一个元素进栈）。
栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。
宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。
宁宁考虑的是这样一个问题：一个操作数序列，从1，2，一直到n，栈A的深度大于n。
现在可以进行两种操作，
1,将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的push操作）。
2,将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的pop操作）。
使用这两种操作，由一个操作数序列就可以得到一系列的输出序列。
你的程序将对给定的n，计算并输出由操作数序列1，2，…，n经过操作可能得到的输出序列的总数。

输入格式
输入文件只含一个整数 n。
输出格式
输出文件只有一行，即可能输出序列的总数目。
数据范围
1≤n≤18
输入样例：
3
输出样例：
5

//卡特兰数列：a[i]=∑a[j][i-1-j] j:[0,i)
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N=20;
int n;
long long dp[20];

int main(){
    cin>>n;
    dp[0]=dp[1]=1;
    for(int i=2;i<=n;i++){
        for(int j=0;j<i;j++){
            dp[i]+=dp[j]*dp[i-j-1];
        }
    }
    cout<<dp[n]<<endl;
    return 0;
}

//这道题还可以用组合去求：
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 40;

int n;
LL C[N][N];

int main()
{
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j <= i; j ++ )
            if (!j) C[i][j] = 1;
            else C[i][j] = C[i - 1][j] + C[i - 1][j - 1];  //这个例子的n可以大一些,上面的递归只能算是到35，这个可以算到100.

    cin >> n;
    cout << C[n * 2][n] / (n + 1) << endl;
	//组合公式：2n中取n，因为一个数放入和取出一共是两步，所以一共是2n次，取其中n次为放入，但是这里有不合法的，如栈中已经没有数了还在取出，所以要减去不合法的数量，
	//不合法的数量是：2n中取n-1个，最后通分得出 C[n * 2][n] / (n + 1)，推导过程见视频，

    return 0;
}




//卡特兰数组
a[i]=∑a[j][i-1-j] j:[0,i)

【应用】

	1,二叉树的计数：已知二叉树有 n 个结点，求能构成多少种不同的二叉树
	2,括号化问题：一个合法的表达式由()包围，()可以嵌套和连接，如：(())()也是合法表达式，现给出 n 对括号，求可以组成的合法表达式的个数
	3,划分问题：将一个凸 n+2 多边形区域分成三角形区域的方法数
	4,出栈问题：一个栈的进栈序列为1,2,3,..n，求不同的出栈序列有多少种
	5,路径问题：在 n*n 的方格地图中，从一个角到另外一个角，求不跨越对角线的路径数有多少种
	6,握手问题：2n 个人均匀坐在一个圆桌边上，某个时刻所有人同时与另一个人握手，要求手之间不能交叉，求共有多少种握手方法

第2和4和5都有一个相同的情况，就是正方形下三角形路径问题，(0,0)到(10,10),只能走右下角三角形，不能过对角线，如括号问题，放了一个'(',相当于向右走了一步，放一个')'，相当于向上走了一步，第三步只能向右走了，因为再向上走就过对角线了，  出栈问题同理，栈中不能有负数个数。

第1和3和6是一样的，1是先确定一个结点，然后计算左边结点的排列数*右边结点排列数，6是先确定两个人握手，然后计算这条线左边的人握手排列数*右边的人握手排列数，    因为握手是两个人的事，所以左右两边不能出现单数，所以总数应该是按2n来算。3是不能和左右相邻的结点连接，所以应该在原来的基础上-2，才是n,这个和握手问题划分是一样的。

n<=35 的卡特兰数的实现
LL h[36];
void init() {
    h[0]=h[1]=1;
    for(int i=2; i<=35; i++) {
        h[i]=0;
        for(int j=0; j<i; j++)
            h[i]=h[i]+h[j]*h[i-j-1];
        cout<<h[i]<<endl;
    }
}

