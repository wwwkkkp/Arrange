
//10.1455.招聘 约瑟夫环问题
给定一组数，是每次加的数
给定一个数，多少个数进行循环
如：
[2,1]
4
有四个数，编号0,1,2,3，轮流按数组中的元素计数，计到的那个数被删除，求最终剩下的是什么数
如
第一次：计数是2，删除编号1，
第二次：计数是1，删除编号2，
第三轮：计数是2，删除编号0.
最终剩下了编号3，即为结果。

输入格式
输入包含多组测试数据。
第一行包含整数 T，表示共有 T组测试数据。
接下来 T行，每行包含若干个整数，依次存放 
n,m,A1,A2,…Am，表示一组数据。
输出格式
输出共 T行，每行对应相应的那组数据确定的录取之人的编号。
数据范围
0<T<10,0<m,Ax<10^3,0<n<10^7
输入样例：
1
4 2 3 1
输出样例：
1

// //约瑟夫环有个递推公式，f[n][k]=(f[n-1][k+1]+a[k])%n;f[n][k]:n个人从数组第k位开始计数，最后剩下的编号，a[k],数组第k位的数，如果不是数组，每次计数的是个定值，
公式就是f[n]=(f[n-1]+m)%n；m为定值
#include<iostream>
#include<algorithm>

using namespace std;
const int M=1010,N=1e7+10;
int T,m,n;
int a[M];
int j;

int main(){
	cin>>T;
	while(T--){
		cin>>n>>m;
		for(int i=0;i<m;i++){
			cin>>a[i];
		}
		int k=(n-1)%m;  //是n和k是线性的,
		j=0;//初始位置是1个人，k+n-1的位置开始计数，因为只有一个人，所以剩下的编号就是0;   最终结果求得是n人，从位置k=0开始，所以不用加k
		
		for(int i=2;i<=n;i++){
			k=(k-1+m)%m; //注意k的迭代，不能小于0
			j=(j+a[k])%i;   //因为这道题数值很大，不适合用数组
		}
		
		cout<<j<<endl;
	}
	return 0;
}


//暴力做法，用链表模拟过程


//约瑟夫环问题：
如果每次走的是定值m，f[n]：从0开始，n个数，每次走m步，最后剩下的数，当走了一次m步以后，淘汰了一个数，剩下n-1个数,但是这个是相当于从m开始的，这时候为了把起始点移动回0，这时候就需要把在在此基础上+m，所以f[n]=(f[n-1]+m)%n;

如果走的是不是定值，是一个数组，其实和上面的原理是一样的，
f[n][k],从0开始，n个数，当前是走数组第k个数步，那下一个数就是走第k+1个数步,反推回来就是(f[n-1][k+1]+a[k])%n;所以 f[n][k]=(f[n-1][k+1]+a[k])%n，参数n,k是线性的
初始情况：f[1][(k+n-1)%n]=0,只有一个人，所以是就是剩下的那个