
//12.2.1026. 乘积最大 
今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰90周年。
在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友 XZ 也有幸得以参加。
活动中，主持人给所有参加活动的选手出了这样一道题目：
设有一个长度为 N的数字串，要求选手使用 K个乘号将它分成 K+1个部分，找出一种分法，使得这 K+1个部分的乘积最大。
同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：
有一个数字串：312， 当 N=3，K=1时会有以下两种分法：
1）3*12=36
2）31*2=62
这时，符合题目要求的结果是：31*2=62。
现在，请你帮助你的好朋友 XZ 设计一个程序，求得正确的答案。
输入格式
第一行共有2个自然数 N，K。
第二行是一个长度为 N的数字串。
输出格式
输出所求得的最大乘积（一个自然数）。
数据范围
2≤N≤10
1≤K≤6
数据保证 
K<N

输入样例：
4 2
1231
输出样例：
62


//因为数据量不大，所以用枚举
#include<iostream>

using namespace std;

const int N=12;

int n,m;
string s;
int rmax;
bool f[N];

void dfs(int t,int k){//第t个空添不添加*，目前已经添加了k个*了
    if(k==m){
        int j=0,res=1;
        for(int i=0;i<n;i++){
            j=j*10+s[i]-'0';
            if(f[i]){
                res*=j;
                j=0;
            }
        }
        res*=j;
        rmax=max(rmax,res);
        return ;
    }
    if(t==n-1)return;
    f[t]=true;
    dfs(t+1,k+1);
    f[t]=false;
    dfs(t+1,k);
}

int main(){
    cin>>n>>m;
    if(n-1<m){
        cout<<0<<endl;
        return 0;
    }
    cin>>s;
    dfs(0,0);
    cout<<rmax<<endl;
    return 0;
}