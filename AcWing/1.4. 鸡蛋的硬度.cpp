//4.1048. 鸡蛋的硬度 
/*
最近XX公司举办了一个奇怪的比赛：鸡蛋硬度之王争霸赛。
参赛者是来自世界各地的母鸡，比赛的内容是看谁下的蛋最硬，更奇怪的是XX公司并不使用什么精密仪器来测量蛋的硬度，他们采用了一种最老土的办法–从高度扔鸡蛋–来测试鸡蛋的硬度，如果一次母鸡下的蛋从高楼的第a层摔下来没摔破，但是从a+1层摔下来时摔破了，那么就说这只母鸡的鸡蛋的硬度是a。
你当然可以找出各种理由说明这种方法不科学，比如同一只母鸡下的蛋硬度可能不一样等等，但是这不影响XX公司的争霸赛，因为他们只是为了吸引大家的眼球，一个个鸡蛋从100 层的高楼上掉下来的时候，这情景还是能吸引很多人驻足观看的，当然，XX公司也绝不会忘记在高楼上挂一条幅，写上“XX公司”的字样–这比赛不过是XX公司的一个另类广告而已。
勤于思考的小A总是能从一件事情中发现一个数学问题，这件事也不例外。
“假如有很多同样硬度的鸡蛋，那么我可以用二分的办法用最少的次数测出鸡蛋的硬度”，小A对自己的这个结论感到很满意，不过很快麻烦来了，“但是，假如我的鸡蛋不够用呢，比如我只有1个鸡蛋，那么我就不得不从第1层楼开始一层一层的扔，最坏情况下我要扔100次。如果有2个鸡蛋，那么就从2层楼开始的地方扔……等等，不对，好像应该从1/3的地方开始扔才对，嗯，好像也不一定啊……3个鸡蛋怎么办，4个，5个，更多呢……”，和往常一样，小A又陷入了一个思维僵局，与其说他是勤于思考，不如说他是喜欢自找麻烦。
好吧，既然麻烦来了，就得有人去解决，小A的麻烦就靠你来解决了。

输入格式
输入包括多组数据，每组数据一行，包含两个正整数 n和 m，其中 n表示楼的高度，m表示你现在拥有的鸡蛋个数，这些鸡蛋硬度相同（即它们从同样高的地方掉下来要么都摔碎要么都不碎），并且小于等于n。
你可以假定硬度为 x的鸡蛋从高度小于等于 x的地方摔无论如何都不会碎（没摔碎的鸡蛋可以继续使用），而只要从比 x高的地方扔必然会碎。
对每组输入数据，你可以假定鸡蛋的硬度在0至 n之间，即在n+1层扔鸡蛋一定会碎。
输出格式
对于每一组输入，输出一个整数，表示使用最优策略在最坏情况下所需要的扔鸡蛋次数。
数据范围
1≤n≤100,1≤m≤10
输入样例：
100 1
100 2
输出样例：
100
14
样例解释
最优策略指在最坏情况下所需要的扔鸡蛋次数最少的策略。
如果只有一个鸡蛋，你只能从第一层开始扔，在最坏的情况下，鸡蛋的硬度是100，所以需要扔100次。如果采用其他策略，你可能无法测出鸡蛋的硬度(比如你第一次在第二层的地方扔,结果碎了,这时你不能确定硬度是0还是1)，即在最坏情况下你需要扔无限次，所以第一组数据的答案是100。
*/


//DP思想 f[i][j]表示：第i层j个鸡蛋最少测试次数

#include<iostream>
#include<algorithm>

using namespace std;
int n,m;
int f[110][10];

int main(){
	while(cin>>n>>m){
    	for(int i=1;i<=n;i++){
    		f[i][1]=i;
    	}
    	for(int j=1;j<=m;j++){
    		f[1][j]=1;
    	}
    	for(int i=2;i<=n;i++)
    		for(int j=2;j<=m;j++){
    			f[i][j]=f[i][j-1];
    			for(int k=1;k<=i;k++)
    				f[i][j]=min(f[i][j],max(f[k-1][j-1],f[i-k][j])+1);
    		}
    	cout<<f[n][m]<<endl;
	}
	return 0;
}



//解释：使用j个鸡蛋测试i层楼所使用的的最小次数，即f[i][j]，初始值是f[i][j-1],就是j-1个鸡蛋测试i层楼所使用的次数
//max(f[k-1][j-1],f[i-k][j])+1:当拿一个鸡蛋从第k层楼掉下去，如果碎了，就只需要测试f[k-1][j-1]次，如果没碎，需要测试f[i-k][j]次，max(f[k-1][j-1],f[i-k][j])就是从第k层掉下去所需要的最多次数()即测出结果所需要的最多次数，然后加上本次测量，就是  max(f[k-1][j-1],f[i-k][j])+1
//min(f[i][j],max(f[k-1][j-1],f[i-k][j])+1)：在所有可能的k次测量中，求最小值



//方法二：DP思想
//f[i][j]：j个鸡蛋测试i次，能够测的最大的楼层，比如2个鸡蛋测试14次能测最多100层楼，

#include<iostream>
#include<algorithm>

using namespace std;
int n,m;
int f[110][10];

int main(){
	while(cin>>n>>m){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++)
			    f[i][j]=1+f[i-1][j-1]+f[i-1][j];   //当测试一次以后，如果碎了，那最多能测f[i-1][j-1]层楼，如果没碎最多能测f[i-1][j]层楼，加上测的那一层楼，就是总的测量层数
			if(f[i][m]>=n)
			{
				cout<<i<<endl;
				break;
			}
		}
	}
	return 0;
}


