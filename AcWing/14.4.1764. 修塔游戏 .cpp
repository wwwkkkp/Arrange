
//14.4.1764. 修塔游戏 

小招正在玩一款修塔游戏，系统中有n座高塔，每座高塔由若干个高度相同的方块堆砌而成，修塔游戏的规则为：
每次从最高塔的塔尖拿走一个方块
每次在最低塔的塔尖堆砌一个方块
小招每次只能完成上述两个动作中的一个动作。
游戏的目标是使 n座高塔中至少有 k座高塔的高度相同，请问小招最少需要多少次才能完成游戏。
输入格式
输入共有2行，第一行为 n和 k，第二行为 n座塔的高度组成的数组 a1,a2,…an。

输出格式
输出值为最少需要多少次动作才能完成游戏。
数据范围
1≤k≤n≤200000
1≤aj≤10000
输入样例：
6 5
1 2 2 4 2 3
输出样例：
3



//思路：因为塔高在[1,10000]之间，那这个相同高度的塔高也在这个区间中，需要枚举，当塔高是h的时候，有3中达到的方式，只修改比h矮的塔，只修改比h大的塔，都修改，求这3*10000种情况中的最小值即可
#include<cstring>
#include<algorithm>
#include<iostream>

using namespace std;

const int N=200010,M=10000,M1=10010;

int n,k;
int s[M1],c[M1],c1[M1];//s:高度小于i的塔高度总和 c：塔高为h的塔的数量  c1:高度小于i的塔数量总和
//int a[N];
int res;//最小修改次数

void minh(int t){
    int le=t*(c1[t])-s[t];//把左边所有塔高都填到t高度
    int ri=s[M]-s[t-1]-t*(n-c1[t-1]);  //把右边所有塔高都消减到t高度
    if(c1[t]>=k)    res=min(res,le-(c1[t]-k));  //只改动左边，因为长度至少是k，不用全填成t，所以至少要填 le-填多的个数
    if(n-c1[t-1]>=k)res=min(res,ri-(n-c1[t-1]-k));   //只改动右边  //和左边相同
     
    res=min(res,le+ri-(n-k));   //左右都修改
}

int main(){
    cin>>n>>k;
    for(int i=0;i<n;i++){
        int h;
        scanf("%d",&h);
        //a[i]=h;
        c[h]++;//塔高为h的塔的数量
        if(c[h]>=k){//如果本来就有相同高度>=k的高度，无需修改，直接退出
            cout<<0<<endl;
            return 0;
        }
    }
    res=2e9;
    //sort(c,c+n);
    for(int i=1;i<=M;i++){
        s[i]=s[i-1]+i*c[i];//高度小于i的塔高总和
        c1[i]=c1[i-1]+c[i];//高度小于i的塔的数量
    }
    for(int i=1;i<=M;i++)
        if(c[i])  //最小修改次数所在的高度一定是塔高中的某个值
            minh(i);
    
    cout<<res<<endl;
    return 0;
}


//为什么 最小修改次数所在的高度一定是塔高中的某个值
反证法：如果不是，目标塔高t在[a,b]之间，a,b在塔高中，t不在
1,如果只修改左边，那高度a的次数一定小于i,
2,如果只修改右边，那高度b的次数一定小于i
3,如果左右都修改，左边修改的多的话，和情况1一样，右边修改的多的话，和情况2一样，一样多的话，那和塔高a,b次数是一样的