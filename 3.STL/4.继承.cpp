//其他关于继承内容看DPF
//4.友元函数、静态成员函数的继承

基类的友元函数是否能被派生类继承呢？答案是否定的，友元函数不能被继承，友元只是能访问指定类的私有和保护成员的自定义函数，不是被指定类的成员，自然不能继承。
使用友元类时注意:

/友元关系不能被继承。/
友元关系是单向的，不具有交换性。（若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。）
友元关系不具有传递性。（若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的声明。）

注意事项：

1.友元可以访问类的私有成员。
2.友元只能出现在类定义内部，友元声明可以在类中的任何地方，一般放在类定义的开始或结尾。
3.友元可以是普通的非成员函数，或在之前定义的其他类的成员函数，或整个类。
4.类必须将重载函数集中每一个希望设为友元的函数都声明为友元。
5.友元关系不能继承，基类的友元对派生类的成员没有特殊的访问权限。如果基类被授予友元关系，则只有基类具有特殊的访问权限。该基类的派生类不能访问授予友元关系的类。

//静态成员及静态成员函数是否能被继承？
我们知道，类的模型是所有对象的数据成员单独存储，但是所有成员函数和静态成员是共用一段空间的 。
那么同样,/在基类和派生类中，静态成员和静态成员函数共用同一段空间。/
/即静态成员和静态成员函数是可以继承的。/

所以，我们可以得出以下结论：

1,/基类的static变量和函数在派生类中依然可用/，但是受访问性控制（比如，基类的private域中的就不可访问）。
2,/对static变量来说，派生类和基类中的static变量是共用空间的/，这点在利用static变量进行引用计数的时候要特别注意。
3,/派生类的friend函数可以访问派生类本身的一切变量，包括从基类继承下来的protected域中的变量/。但是对基类来说，它并不是friend的。

//赋值兼容性规则
继承结构，是从上到下的结构（即从基类到子类的结构）,/但只支持从下到上的转换，即不允许从上到下的转换。/
class A{};
class B:public A{};
int main(){
	A a;
	B b;
	A c=b;//允许
	B d=a;//不允许
}


//总结如下：
所谓赋值兼容规则，即在任何需要基类对象的地方都可以用该基类的公有派生类的对象来代替，它主要包括以下情况：

1,/派生类的对象可以赋值给基类的对象/，此时的赋值操作主要是把派生类对象中所包含的对应基类的子对象赋值给基类对象。
2,/派生类对象的地址可以赋值给其基类的指针变量/,只能通过该指针访问派生类中由基类继承来的隐藏对象,/不能访问派生类中的新成员/
3,/派生类对象可以初始化基类的引用/,只能通过该引用访问派生类中由基类继承来的隐藏对象,/不能访问派生类中的新成员/
