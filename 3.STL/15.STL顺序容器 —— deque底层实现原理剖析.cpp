
//15.STL顺序容器 —— deque底层实现原理剖析

deque和vector的最大差异,
/一在于deque允许常数时间内对其头端进行元素的插入或移除操作/,/二在于deque没有所谓的容量概念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来/。

//deuqe中控器
,
/deque是由一段一段的 定量 连续空间构成/。由一个中控器统一管理这些连续的空间，称为map,是一个二维指针,/map是一小块连续空间，其中每个元素(此处称为一个节点，node)都是指针，指向另一段(较大的)连续线性空间，称为缓冲区/。缓冲器大小默认512k

deque有两个迭代器，分别是start和finish，分别是头尾的两个 迭代器，这里简单说下原理，具体见https://zhaoyang.blog.csdn.net/article/details/89716913

头尾原理是一样的，这里就说一下尾，
1,当尾部要添加数字，检查当前缓冲区用完没有，
	if(当前缓冲区用完){
		if(map中控器空间用完){
			重新开辟一块空间，将map中的地址链接复制过去，然后析构原来的map；//注意换过map以后，迭代器同时失效
		}
		开辟一个新的缓冲区(512k)，在map上开辟一个结点(node)，该node指向这个缓冲区，把添加的数字存入；
	}else if(当前缓冲区没有用完){
		直接添加；
	}
2,当尾部需要删除数据的时候，
	if(最后一个数据是某缓冲区的第一个数){
		删除这个数；
		释放该缓冲区；
		释放map中的对应结点；
	}else if(最后一个数据不是第一个数){
		直接删除；
	}
3,clear()函数；
	注意:/deque的最初状态（无任何元素时）保有一个缓冲区，因此，clear()完成之后恢复初始状态，一样要保留一个缓冲区/

4,erase()函数1：
	删除deque中的某个元素；
	1),判断这个元素是在deque的前半部分还是后半部分；
	2),如果是后半部分，就将这个元素后面的数向前移动一位，覆盖这个数；
	3),删除最后一个元素；

5,erase()函数2：
	删除deque中的某段元素[a,b)：
	1),判断这段元素离头近还是离尾近；
	2),如果离尾近，移动b后的元素，覆盖这一段，
	3),删除最后b-a个元素
