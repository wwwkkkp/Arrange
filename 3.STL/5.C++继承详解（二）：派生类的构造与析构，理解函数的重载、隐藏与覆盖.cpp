
//5.C++继承详解（二）：派生类的构造与析构，理解函数的重载、隐藏与覆盖

派生类的构造函数：

释放对象的顺序与创建对象的顺序相反．即首先执行派生类的析构函数，然后自动调用基类的析构函数。

class A{
	public:
		A(){cout<<"a"<<endl;}
		~A(){cout<<"~a"<<endl;}
};
class B:public A{
	public:
		B():A(){cout<<"b"<<endl;}
		~B(){cout<<"~b"<<endl;}
};
int main(){
	A a=new B();
	delete a;
	return 0;
}

输出：
a
b
~a

上面有一个问题，就是 当基类对象指向派生类对象 时，无法调用派生类中的新函数和数据结构
解决办法：在基类的析构函数上使用虚析构函数，
class A{
	public:
		A(){cout<<"a"<<endl;}
		virtual ~A(){cout<<"~a"<<endl;}  //虚析构函数
};
使用虚析构函数可以确保正确的析构函数序列被调用。


//函数重载：同一个类中的函数，名字一样 参数类型，顺序，返回值不一样
//函数隐藏：派生类的函数屏蔽了与其同名的基类函数。
			1.派生类和基类，名字相同，参数不同，无论有无virtual，基类函数被隐藏
			2.派生类和基类，名字相同，参数相同，无virtual，      基类函数类隐藏
//函数覆盖：派生类和基类，名字相同，参数相同，有virtual，        基类函数被覆盖


重载和覆盖的关系
1,/覆盖是派生类和基类之间（不同作用域）的关系，是垂直关系；重载是在同一个作用域方法之间的关系，是水平关系。/
2,覆盖只能由一对方法产生关系；重载是两个或多个方法之间的关系。
3,/覆盖要求参数列表相同；重载要求参数列表不同。/
4,覆盖关系中，调用方法是 根据对象的类型 来决定的，重载关系是,/根据函数的不同形参列表/来选择方法体的。
