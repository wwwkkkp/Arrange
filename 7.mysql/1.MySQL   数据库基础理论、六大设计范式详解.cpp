


//MySQL   数据库基础理论、六大设计范式详解

MySQL是一个开源的 关系型数据库 管理系统，

//关系型数据库与非关系型数据库
,/关系型数据库：指采用了关系模型来组织数据的数据库。

关系模型中常用的概念：

1,关系：一张二维表，每个关系都具有一个关系名，也就是表名
2,元组：二维表中的一行，在数据库中被称为记录
3,属性：二维表中的一列，在数据库中被称为字段
4,域：属性的取值范围，也就是数据库中某一列的取值限制
5,关键字：一组可以唯一标识元组的属性，数据库中常称为主键，由一个或多个列组成
6,关系模式：指对关系的描述。其格式为：关系名(属性1，属性2， … … ，属性N)，在数据库中成为表结构

关系型数据库的优点：

1,容易理解：二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来说更容易理解
2,使用方便：通用的SQL语言使得操作关系型数据库非常方便
3,易于维护：丰富的完整性(实体完整性、参照完整性和用户自定义完整性)大大减低了数据冗余和数据不一致的概率

数据库事务必须具备ACID特性，ACID分别是Atomic原子性，Consistency一致性，Isolation隔离性，Durability持久性

,/非关系型数据库，又被称为NoSQL（Not Only SQL )，意为不仅仅是SQL，指非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统。
非关系型数据库以键值对<Key, Value>存储，且结构不固定，每一个元组(行)可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，不局限于固定的结构，可以减少一些时间和空间的开销。


,/关系型与非关系型数据库的比较:

1,成本：非关系型数据库成本低
2,查询速度：Nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及Nosql数据库。
3,存储格式：Nosql的存储格式是<key,value>形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而关系型数据库则只支持基础类型。
4,扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。Nosql基于键值对，数据之间没有耦合性，所以非常容易水平扩展。
5,持久存储：Nosql不使用于持久存储，海量数据的持久存储还是需要关系型数据库
6,数据一致性：	非关系型数据库一般强调的是数据最终一致性，不像关系型数据库一样强调数据的强一致性，
				从非关系型数据库中读到的有可能还是处于一个中间态的数据,/Nosql不提供对事务的处理。

,/MySQL Server或者说mysqld，实际上是一个数据库服务器程序。它管理着对磁盘数据库和内存的访问。MySQL Server进行多线程操作，它支持多个客户端连接的同时访问。

,/总结
1,MySQL设计成C/S客户端服务器模型，应用作为MySQL Client向MySQL Server发送请求，获取响应，因此MySQL非常适用于集群环境，方便做主从复制，读写分离操作。
2,	为了提高效率，MySQL Client和MySQL Server如果处在不同主机上，是通过Socket进行网络通信的;
	/如果它们在同一台机器上，那么Client和Server之间是通过 共享内存 进行通信的，效率比Socket通信更高。
3,/MySQL的服务器模块采用的是IO复用+可伸缩的 s线程池，是实现网络高并发服务器的经典模型。


备注：	1. 线程池的概念：
			线程池就是首先创建一些线程，它们的集合称为线程池。使用线程池可以很好地提高性能，
			/*线程池在系统启动时即创建大量空闲的线程，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，
			执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。*/
		2. 线程池的工作机制
			2.1 在线程池的编程模式下，任务是提交给整个线程池，而不是直接提交给某个线程，线程池在拿到任务后，就在内部寻找是否有空闲的线程，如果有，则将任务交给某个空闲的线程。
			2.2 一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。
		3. 使用线程池的原因：
			多线程运行时间，系统不断的启动和关闭新线程，成本非常高，会过渡消耗系统资源，以及过渡切换线程的危险，从而可能导致系统资源的崩溃。
			这时，线程池就是最好的选择了。



//数据库的范式设计  (范式：就是规则，数据库的设计规则)

,/关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴德斯科范式（BCNF）、第四范式（4NF）和第五范式（5NF）。
,/一般说来，数据库只需满足第三范式（3NF）就行了。

越高的范式数据库的冗余度就越低。

范式设计的优点：
	减少数据冗余
	消除异常（插入异常，更新异常，删除异常）
	让数据组织的更加和谐

,/数据库范式绝对不是越高越好，范式越高，意味着表越多，多表联合查询的机率就越大，SQL的效率就变低。

泛化:在识别数据库中的一个数据元素、关系以及定义所需的表和各表中的项目这些初始工作之后的一个细化的过程。

//基础概念：关键码、属性与函数依赖、多值依赖

,/关键码与属性:
	候选码和主码：表中可以唯一确定一个元组的某个属性（或者属性组）叫候选码，我们从许多个候选码中挑一个就叫主码。
	全码：如果一个码包含了所有的属性，这个码就是全码。
	主属性：一个属性只要在任何一个候选码中出现过，这个属性就是主属性。
	非主属性：与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。
	外码：一个属性（或属性组），它不是码，但是它别的表的码，它就是外码。

,/函数依赖：输入一个属性X，就可以查出另一个属性Y,称Y依赖于X，记作X→Y，如关系(学号 姓名 性别)，输入学号就开可以查出性别，说性别依赖于学号
函数依赖三种方式：部分依赖、完全依赖、传递依赖

部分依赖：	如果X→Y，存在X的真子集X1，使得X1→Y，则称Y部分依赖于X。也就是Y依赖于部分的X。
			如：学生表(学号, 姓名, 性别, 班级, 年龄)，(学号, 姓名)→性别，学号→性别，所以(学号, 姓名)→性别是部分函数依赖。
完全依赖：	如果X→Y，但任何X的真子集X1都不存在X1→Y则称Y完全依赖于X。
			如：成绩表(学号, 课程号, 成绩)，(学号, 课程号)→成绩，学号!→成绩，课程号!→成绩，所以(学号, 课程号)→成绩是完全函数依赖。
传递依赖：	如果X→Y，Y→Z，X⊄Y，Y!→X，(X∪Y)∩Z=∅，则称Z传递依赖于X。
			如：关系S(学号, 系名, 系主任)，学号→系名，系名→系主任，系名!→学号，所以学号→系主任为传递函数依赖。


函数依赖与属性的关系
设R(U)是属性集U上的关系模式，X、Y是U的子集。
如果X和Y之间是一对一（1:1）关系，如学校和校长，则存在函数依赖X→Y和Y→X。
如果X和Y之间是一对多（1:n）关系，如年龄和姓名，则存在函数依赖Y→X。
如果X和Y之间是多对多（m:n）关系，如学生和课程，则X和Y之间不存在函数依赖。

//第一范式（1NF）：每一列保持原子特性
	,/数据库表的每一列都是不可分割的原子数据项，不能是集合，数组，记录等非原子数据项。
	在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。
	
//第二范式（2NF）：属性完全依赖于主键
	第二范式建立在第一范式的基础上，即满足第二范式一定满足第一范式。
	,/第二范式要求数据表每一个实例或者行必须被唯一标识,所有属性都依赖于主键，
	当数据表中是联合主键，但是有的列只依赖联合主键中的一个或一部分属性组成的联合主键，此时需要 拆表 才能符合第二范式。
	如果不拆表，会存在下述问题：
		数据冗余，每条记录都含有相同信息
		删除异常：删除所有学生成绩，就把课程信息全删除了；
		插入异常：学生未选课，无法记录进数据库
		更新异常：调整课程学分，所有行都调整

//第三范式（3NF）：属性不依赖于其它非主属性
	,/若某一范式是第二范式，且每一个非主属性都不传递依赖于该范式的候选键，则称为第三范式。
	即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。
	如关系(员工ID,姓名,部门ID,部门名称)	部门名称依赖于部门ID，部门ID依赖于员工ID，这个是不行的，所以要拆表，
		把上面关系拆成关系1(员工ID,姓名,部门ID)和关系2(部门ID,部门名称)，就可以了

/*
总结：
	第一范式：列不能再分
	第二范式：建立在第一范式基础上，消除部分依赖
	第三范式：建立在第二范式基础上，消除传递依赖
*/

//巴德斯科范式（BCNF）：每个表中只有一个候选键
	,/要求关系模型中所有的属性（包括主属性和非主属性）都不传递依赖于任何候选关键字
	,/BCNF实际上是在第三范式的基础上，进一步消除了主属性的传递依赖。
	如关系(员工ID,姓名,部门ID,email) 每个员工的email是唯一的，所以员工ID和email属于1:1关系,员工ID→email,email→员工ID,这是不行的，要拆表
	拆成关系1(员工ID,姓名,部门ID)和关系2(email,员工ID)就行了。

//第四范式（4NF）：互相独立的非主属性无多值
	,/表中不能包含一个实体的两个或多个互相独立的多值因子,当一个表中的非主属性互相独立时（3NF），这些非主属性不应该有多值
	当一个人有多个移动电话和固定电话的时候，如：
	用户		移动号码       固定号码
	1			1234			1593
	1			5678			1536
	
	移动电话和固定电话是相互独立的，但是他们都有多个值，这是不允许的，会有麻烦：如果用户放弃第一行的固定电话和第二行的移动电话，那么这两行会合并吗？
	
	修改成
	
	用户		电话			类型
	1			1234			1
	1			5678			1
	1			1593			2
	1			1536			2
	
	这样就可以了类型中1代表移动电话，2代表固定电话

//第五范式（5NF）：处理相互依赖的多值情况
	第五范式有以下要求：
		必须满足第四范式
		表必须可以分解为较小的表，除非那些表在逻辑上拥有与原始表相同的主键。
	

数据库应用的范式越高，表越多。表多会带来很多问题：

	查询时需要连接多个表，增加了SQL查询的复杂度
	查询时需要连接多个表，降低了数据库查询性能

,/因此，并不是应用的范式越高越好，要看实际情况而定。 第三范式已经很大程度上减少了数据冗余，并且基本预防了数据的插入异常，更新异常，和删除异常了。
