


//深入程序编译链接和装载过程

linux是用gcc编译.c程序的，编译过程可以分成四部分：/*预处理  编译 汇编 链接*/

GCC的命令其实是对一些编译程序的包装而已，它根据不同的参数去调用预编译程序（cpp）、汇编器（as）、链接器（ld）。

预处理，生成预编译文件（.i文件）： gcc –E hello.c –o hello.i   也可以是cpp hello.c > hello.i    //-E 表示只进行预编译
编译，生成汇编代码（.s文件）：gcc –S hello.i –o hello.s       原始文件通过预处理程序生成编译文件
汇编，生成目标文件（.o文件）：gcc –c hello.s –o hello.o  汇编文件通过汇编器生成汇编文件
链接，生成可执行文件：gcc hello.o –o hello     汇编文件通过链接器链接库，生成可执行文件


hello.c
#include<iostream>
int main(){
	printf("helloword");
	return 0;
}

//预处理
源代码文件 hello.c和相关的头文件，如 stdio.h 等被 预编译器cpp  预编译成一个 .i 的文件(C++被编译成.ii文件)


预编译过程主要处理那些源代码文件中的以 " # " 开始的预编译指令。比如 " #include "、" #define "、"#pragma"等，主要处理规则如下：

#include： 将被包含的文件插入到该预编译指令的位置。注意：该过程递归进行，也就是说被包含的文件可能还包含其他文件。
#define ： 删除define，并且展开所有的宏定义
#pragma :  保留所有的 #pragma 编译器指令，因为编译器须要使用它们；

删除所有的注释" // "和  " /* */ "；
处理所有条件编译指令，如" #if "，" #ifdef "，" #elif "，" #else "，" #endif "；
添加行号和文件标识，如 #2 " hello.c " 2，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号；

#pragma:主要有三种：
#pragma once:用于保证头文件只被编译一次,如果出现#include "a.h" #include "a.h",就只需要编译一次
#pragma message : 用于自定义编译信息，看#define 是否成功，在.i文件中可以看到，如果成功有显示

				#include <stdio.h>
				#define ANDROID20
				 
				#if defined ANDROID20
				   #pragma message "Compile Android SDK 2.0..."
				   #define VERSION "Android 2.0"
				#elif defined ANDROID30
				   #pragma message "Compile Android SDK 3.0..."
				   #define VERSION "Android 3.0"
				#endif

#pragama pack:用于指定内存对齐(一般用在结构体):
					#pragma pack(4)  //最大支持4字节对齐
					struct S2
					{               //  地址 
						char c;    //    0 
						int a[2];  //    4-7
						double e;  //   12-20
					};
					#pragma pack()

					int main()
					{
						S2 s;
						printf("sizeof(struct S2) = %d\n", sizeof(struct S2));   
						//如果没有 #pragma pack(4)，输出默认值24，有#pragma pack(4)，以4对齐，那double就是以12为首地址，而不是原来的16(8对齐)，输出20
						return 0;
					}


//编译

编译过程通过词法和语法分析，确认所有指令符合语法规则(否则报编译错)，之后翻译成对应的中间码，在Linux中被称为RTL(Register Transfer Language)，通常是平台无关的，/**这个过程也被称为编译前端。编译后端对RTL树进行裁减，优化，得到在目标机上可执行的汇编代码*/。
gcc采用as作为其汇编器，所以汇编码是AT&T格式的，而不是Intel格式，所以在用gcc编译嵌入式汇编时，也要采用AT&T格式。

编译是程序构建的核心部分，也最复杂。需要在这个过程中完成/**词法分析、语法分析、语义分析及优化产生的汇编代码*/。

//汇编
汇编器将上面生成的汇编代码转为机器可以执行的指令。

//链接
在成功汇编之后，就进入了链接阶段。在这里涉及到一个重要的概念：函数库。

在Hello World 程序中并没有定义 " printf " 的函数实现，且在预编译中包含进的 " stdio.h " 中也只有该函数的声明，而没有定义函数的实现，那么，是在哪里实现" printf " 函数的呢？通过链接函数库

函数库一般分为静态库和动态库两种。
静态库：指编译链接时，/*把库文件的代码全部加入到可执行文件中*/，因此生成的文件比较大，但在运行时也就不再需要库文件了。其后缀名一般为 " .a " 。
动态库：在编译链接时,/*并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库*/，这样可以节省系统的开销。动态库一般后缀名为 " .so "			gcc在编译时默认使用动态库。
 
下面的指令可以生成静态链接库hello.a
ar -v -q hello.a hello.o

动态库在链接时/*只创建一些符号表，而在 运行 的时候才将 有关库的代码 装入内存，映射到运行时相应进程的虚地址空间*/。如果出错，如找不到对应的.so文件，会在执行的时候报动态连接错(可用LD_LIBRARY_PATH指定路径)。


//深入编译链接和运行
cpu io 内存：
为了访问方便，操作系统提供了/*VFS虚拟文件系统*/，屏蔽了I/O层的差异
为了屏蔽内存和I/O，作为资源分配的管理单位，提供了 虚拟内存 
为了屏蔽CPU、内存、I/O底层的差异，作为这三个部件的资源调度单位，操作系统提供了 进程 的概念

操作系统内核将底层的硬件都屏蔽起来了，那么只要有操作系统在，/*我们写的代码生成的可执行文件是不可能直接被加载到物理内存上去的，他会被加载到虚拟内存上*/。虚拟内存的大小，与CPU的位数有关。虚拟内存再映射到物理内存上

数据总线和系统位数有关，如32位系统的数据总线根数是32位，但是地址总线和系统位数无关。/*CPU的位数是指它一次性能加以运算的最长的整数的宽度*/


//32位4GLinux虚拟地址空间布局
以32位系统为例；其中低3G为用户空间，是供用户的应用程序执行的，高1G为内核空间，主要是供内核代码运行的；每一个进程的用户控件都是独立的，所有进程的内核空间都是共享的。

各存储器在内存中的位置分布
低位                                                  高位
1      2      3      4      5      6     7     8       9

1.不可用空间：0-128M
2.text段：可执行指令，字面值常量，具有常属性且被初始化的全局变量和静态局部变量，注：字面值常量：true false 0x(16进制) 0(8进制) l(长整型) 各种转义符(\n)等 		 	，如果带了0x等量的数为常属性变量
3.data段：保存已经初始化的全局变量和静态局部变量
4.bss段：未被初始化的全局变量和静态局部变量
//注意：2-4的大小是在程序运行前就固定的，程序运行期间是不会改的,同时text和data在可执行文件中
5.堆区：动态分配内存，程序运行时需要内存空间的时候申请
6.堆栈增长的预留空间：存储共享库，共享内存等
7.栈区：非静态局部变量
8.命令行和参数和环境变量
10.内核空间
	内核空间分为3部分：
	低16M：ZONE_DMA直接访问内存
	中间的892M：ZONE_NORMAL
	高的128M：ZONE_HIGHMEM高端内存
	
//程序运行起来至少需要 text data 栈

//

