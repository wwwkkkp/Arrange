

//3. 类与对象基础

//面向过程 面向对象

面向过程是具体的东西，面向过程是面向对象的基础。

面向过程是具体化的，流程化的。解决一个问题，需要一步一步分析需要怎样，然后需要怎样，一步一步实现的。
面向对象是模型化的，抽象出一个类，这是一个封闭的环境，在这个环境中有数据有解决问题的方法，你如果需要什么功能直接使用就可以了，至于是怎么实现的，你不用知道。

//面向过程与面向对象的优缺点
面向过程
优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
缺点：没有面向对象易维护、易复用、易扩展
面向对象
优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性， 可以设计出低耦合的系统，使系统更加灵活、更加易于维护
缺点：性能比面向过程低


//面向对象（oop）
面向对象四大特征：抽象 封装 继承 多态

抽象
数据抽象是指只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。

封装和数据隐藏
封装也叫做信息封装，指在设计和确定模块时，使得一个模块内包含的信息（过程或数据），对于不需要这些信息的模块来说，是不能访问的。
数据隐藏：防止程序直接访问数据被称为数据隐藏，数据隐藏不仅可以防止直接访问数据，还让开发者(类的用户)无需了解数据是如何被表示的。

继承
如果一个类A继承自另一个类B，就把这个A称为"B的子类"，而把B称为"A的父类"。继承可以使得子类具有父类的各种属性和方法，而不需要再次编写相同的代码。

多态
同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。简单的说:就是用基类的引用指向子类的对象。

//类的概念
类是面向对象程序设计中的概念，是面向对象编程的基础。

类是对现实生活中一类具有共同特征的事物的抽象。

//类的三大特性
1、封装性
将数据和操作封装为一个有机的整体，由于类中私有成员都是隐藏的，只向外部提供有限的接口，所以能够保证内部的高内聚性和与外部的低耦合性。用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员，能够增强安全性和简化编程。
2、继承性
继承性更符合认知规律，使程序更易于理解，同时节省不必要的重复代码。
3、多态性
同一操作作用于不同对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。

//类与结构体的区别
类是C++中面向对象独有的，但是C和C++中都有结构体。

C和C++中 结构体 的区别
1、/*C结构体中不能包含函数*/，C++结构体仍然可以定义类，允许有内部成员函数。
2、C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的，和类一样，实现了代码的复用。
4、访问权限：C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种。
5、C定义结构体变量时需要加struct关键字，C++中定义结构体变量时可以不加struct关键字。
6、gcc下分别用C和C++定义空结构体，sizeof() 后的结果分别为0 和 1，vs下C 要求一个结构或联合至少有一个成员。
    一个类能够实例化，编译器就需给它分配内存空间，来指示类对象的地址。
	这里编译器默认分配了一个字节（如：char），以便标记可能初始化的类对象，同时使空类占用的空间也最少（即1字节）。

C++的结构体和C++类的区别
 主要是访问权限的区别：
1、C++结构体内部成员变量及成员函数默认的访问级别是public，而c++类的内部成员变量及成员函数的默认访问级别是private。
2、C++结构体的继承默认是public，而c++类的继承默认是private。


//构造函数：
构造函数分为以下几类：
默认构造函数   :系统自动创建，没有参数
带参构造函数   :自己创建，创建对象的时候要给参数
拷贝构造函数   :见下一章
赋值构造函数   :见下一章
构造函数初始化成员有两种方式：
赋值初始化
列表初始化


必须使用类构造函数初始化列表的情况：
const类成员或被声明为引用的类成员。因为const对象或引用类型只能初始化，不能对它们赋值。

注意：数据成员的初始化顺序与它们在 类中声明的顺序 相同，与初始化列表中的排列顺序无关。初始化是从右到左的
如：Test(int data = 100) : mb(data), ma(mb){}
     先初始化的是ma，再初始化mb

在一般情况下，/*调用析构函数的次序正好与调用构造函数的次序相反，可以简记为：先构造的后析构，后构造的先析构，它相当于一个栈，先进后出。*/


//this指针

this指针是隐含在 非静态成员函数 中的特殊指针，它是当前正在调用此成员函数的对象的指针。
当类对象调用成员方法时，把该对象的地址当做实参传递进去；那么所有成员方法在编译时期就会自动添加一个形参，该形参就是this指针，在成员方法中，用来区分不同的对象。

this指针的使用
1、在类的非静态成员函数中返回对象的本身时候，直接用 return *this (常用于操作符重载和赋值、拷贝等函数)。
2、传入函数的形参与成员变量名相同时，例如：this->n = n (不能写成n = n)

//关于this指针的几个问题
1、为什么this指针不能再静态函数中使用?
静态成员函数并不是针对某个类的实例对象，而是属于整个类的，为所有的对象实例所共有。其作用域的范围内是全局的，独立于类的对象之外的，它只对类内部的静态成员变量做操作。当实例化一个类的对象时候，里面不存在静态成员的。this指针是相当于一个类的实例的指针，this是用来操作对象实例的内容的，既然静态成员函数和变量都是独立于类的实例对象之外的，它就不能使用this指针，也不能操作静态成员。
2、this指针是什么时候创建的?
this在成员函数的开始执行前构造的，在成员的执行结束后清除。
3、this指针如何传递给类中函数的？绑定？还是在函数参数的首参数就是this指针，那么this指针又是如何找到类实例后函数的?
this是通过函数参数的首参数来传递的。this指针是在调用之前生成的。类实例后的函数，没有这个说法。类在实例化时，只分配类中的成员变量空间，并没有为成员函数分配空间。
this指针只有在成员函数中才有定义。因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们也无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，是可以知道this指针的位置的（可以&this获得)。
