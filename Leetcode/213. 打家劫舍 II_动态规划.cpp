/* 213. 打家劫舍 II
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:

输入: [2,3,2]
输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
示例 2:

输入: [1,2,3,1]
输出: 4
解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。

*/

//动态规划
//有两种情况，一个是以第n个数为结尾，一个是以第n-1个数为结尾，如果以第n个数为结尾，那第一个数就不能选，只能从第二个数开始，如果是以第n-1个数为结尾，那就可以从第一个数开始，
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size()==0) return 0;
        if(nums.size()==1) return nums[0];
        if(nums.size()==2) return max(nums[0],nums[1]);
        vector<int>Vec1(nums.size());//以第一个数开始
        vector<int>Vec2(nums.size());//以第二个数开始
        Vec1[0]=nums[0];//只有一个数，就是他本身
        Vec1[1]=max(nums[0],nums[1]);//两个数的话就是他们中的最大值
        for(int i=2;i<nums.size()-1;i++){ //迭代到n-1的时候就结束的
            Vec1[i]=max(Vec1[i-1],Vec1[i-2]+nums[i]);//因为不能挨着，所以就有选不选当前数的区别，不选的话，就等于前一个位置的数，选的话就是前两个位置的值与当前的和，
        }
        Vec2[0]=0;
        Vec2[1]=nums[1];//以第二个数开始
        Vec2[2]=max(nums[1],nums[2]);//和上面同理
        for(int i=3;i<nums.size();i++)        
            Vec2[i]=max(Vec2[i-1],Vec2[i-2]+nums[i]);
        return max(Vec1[nums.size()-2],Vec2[nums.size()-1]);
    }
};


//5.29版本
class Solution {
public:
    int rob(vector<int>& nums) {
        int n=nums.size();
        if(!n)return 0;
        if(n==1)return nums[0];
        nums.insert(nums.begin(),0);
        int f[1000];
        int g[1000];
        
        f[0]=0;
        f[1]=nums[1];
        for(int i=2;i<=n-1;i++){
            f[i]=max(f[i-1],f[i-2]+nums[i]);
        }
        g[0]=g[1]=0;
        g[2]=nums[2];
        for(int i=3;i<=n;i++){
            g[i]=max(g[i-1],g[i-2]+nums[i]);
        }
        return max(f[n-1],g[n]);
    }
};

/*
解题思路：
总体思路：
此题是 198. 打家劫舍 的拓展版： 唯一的区别是此题中的房间是环状排列的（即首尾相接），而 198.198. 题中的房间是单排排列的；而这也是此题的难点。

环状排列意味着第一个房子和最后一个房子中只能选择一个偷窃，因此可以把此环状排列房间问题约化为两个单排排列房间子问题：

在不偷窃第一个房子的情况下（即 nums[1:]nums[1:]），最大金额是 p_1p 
1
​	
  ；
在不偷窃最后一个房子的情况下（即 nums[:n-1]nums[:n−1]），最大金额是 p_2p 
2
​	
  。
综合偷窃最大金额： 为以上两种情况的较大值，即 max(p1,p2)max(p1,p2) 。
下面的任务则是解决 单排排列房间（即 198. 打家劫舍） 问题。推荐可以先把 198.198. 做完再做这道题。

198. 解题思路：
典型的动态规划，以下按照标准流程解题。

状态定义：
设动态规划列表 dpdp ，dp[i]dp[i] 代表前 ii 个房子在满足条件下的能偷窃到的最高金额。
转移方程：
设： 有 nn 个房子，前 nn 间能偷窃到的最高金额是 dp[n]dp[n] ，前 n-1n−1 间能偷窃到的最高金额是 dp[n-1]dp[n−1] ，此时向这些房子后加一间房，此房间价值为 numnum ；
加一间房间后： 由于不能抢相邻的房子，意味着抢第 n+1n+1 间就不能抢第 nn 间；那么前 n+1n+1 间房能偷取到的最高金额 dp[n+1]dp[n+1] 一定是以下两种情况的 较大值 ：
不抢第 n+1n+1 个房间，因此等于前 nn 个房子的最高金额，即 dp[n+1] = dp[n]dp[n+1]=dp[n] ；
抢第 n+1n+1 个房间，此时不能抢第 nn 个房间；因此等于前 n-1n−1 个房子的最高金额加上当前房间价值，即 dp[n+1] = dp[n-1] + numdp[n+1]=dp[n−1]+num ；
细心的我们发现： 难道在前 nn 间的最高金额 dp[n]dp[n] 情况下，第 nn 间一定被偷了吗？假设没有被偷，那 n+1n+1 间的最大值应该也可能是 dp[n+1] = dp[n] + numdp[n+1]=dp[n]+num 吧？其实这种假设的情况可以被省略，这是因为：
假设第 nn 间没有被偷，那么此时 dp[n] = dp[n-1]dp[n]=dp[n−1] ，此时 dp[n+1] = dp[n] + num = dp[n-1] + numdp[n+1]=dp[n]+num=dp[n−1]+num ，即可以将 两种情况合并为一种情况 考虑；
假设第 nn 间被偷，那么此时 dp[n+1] = dp[n] + numdp[n+1]=dp[n]+num 不可取 ，因为偷了第 nn 间就不能偷第 n+1n+1 间。
最终的转移方程： dp[n+1] = max(dp[n],dp[n-1]+num)dp[n+1]=max(dp[n],dp[n−1]+num)
初始状态：
前 00 间房子的最大偷窃价值为 00 ，即 dp[0] = 0dp[0]=0 。
返回值：
返回 dpdp 列表最后一个元素值，即所有房间的最大偷窃价值。


*/



