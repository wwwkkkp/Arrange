/*  44. 通配符匹配
给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。

'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
两个字符串完全匹配才算匹配成功。

说明:

s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。
示例 1:

输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
示例 2:

输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。
示例 3:

输入:
s = "cb"
p = "?a"
输出: false
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
示例 4:

输入:
s = "adceb"
p = "*a*b"
输出: true
解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
示例 5:

输入:
s = "acdcb"
p = "a*c?b"
输入: false

*/

//动态规划

class Solution {
public:
    bool isMatch(string s, string p) {
        int s1=s.size();
        int s2=p.size();
        vector<vector<int>> dp(s2+1,vector<int>(s1+1,0));  //p是横坐标，s是纵坐标，意思是 s[0:i]和p[0:j]是否匹配
        dp[0][0]=1;
        for(int i=1;i<s1+1;i++)  //初始值
            dp[0][i]=0;
        for(int i=1;i<s2+1;i++){
            if(p[i-1]=='*')
                dp[i][0]=dp[i-1][0]; 
            else
                dp[i][0]=0;
        }
		
		
        for(int i=1;i<s2+1;i++){
            for(int j=1;j<s1+1;j++){
                if(s[j-1]==p[i-1]||p[i-1]=='?')  //如果是匹配的，那就和上一个的结果是一样的
                    dp[i][j]=dp[i-1][j-1];
                else if(p[i-1]=='*')
                    dp[i][j]=max(dp[i-1][j],max(dp[i][j-1],dp[i-1][j-1])); //如果周边有能匹配的，那*都能匹配
                else if(s[j-1]!=p[i-1])  //结尾不相等的是肯定不能匹配的
                    dp[i][j]=0;
                
            }
        }
        return dp[s2][s1];
    }
};


/*

题目分析 
题目给定两个字符串，一个字符串是匹配串，除了小写字母外，匹配串里面还包含 * 和 ? 这两个特殊字符，另一个是普通字符串，里面只包含小写字母。
题目问这个普通字符串是否和匹配字符串相匹配，匹配规则是 ? 可以匹配单个字符，* 可以匹配一个区间，也就是多个字符，当然也可以匹配 0 个字符，也就是空串。
依然是四个步骤走一遍：
问题拆解
做多了，你发现这种问题其实都是一个套路，老样子，我们还是根据我们要求解的问题去看和其直接相关的子问题，我们需要求解的问题是 pattern(0…m) 和 str(0…n) 是否匹配，这里的核心依然是字符之间的比较，但是和之前不同的是，这个比较不仅仅是看两个字符相不相等，它还有了一定的匹配规则在里面，那我们就依次枚举讨论下：

pattern(m) == str(n):
问题拆解成看子问题 pattern(0...m-1) 和 str(0...n-1) 是否匹配

pattern(m) == ?:
问题拆解成看子问题 pattern(0...m-1) 和 str(0...n-1) 是否匹配

``<br />pattern(m) == *:</p></li> <li><p>可以匹配空串、以及任意多个字符<br />当 * 匹配空串时：问题拆解成看子问题 pattern(0…m-1) 和 str(0…n) 是否匹配<br />当 * 匹配任意字符时：问题拆解成看子问题 pattern(0…m) 和 str(0…n-1) 是否匹配<br />`` 这里解释一下，匹配任意多个字符意味着之前的子问题也可以使用当前的，也就是用 pattern(m) 来进行匹配，因此，当前问题可以拆解成子问题 pattern(0…m) 和 str(0…n-1) 是否匹配，你发现弄来弄去，子问题依然是那三个：

pattern(0…m-1) 和 str(0…n-1) 是否匹配
pattern(0…m-1) 和 str(0…n) 是否匹配
pattern(0…m) 和 str(0…n-1) 

不知道你是否发现了字符匹配类动态规划问题的共性，如果是画表格，你只需要关注当前格子的 左边、上边、左上 这三个位置的相邻元素，因为表格有实际数据做辅助，所以画表格有时可以帮助你找到问题与子问题之间的联系。

状态定义
还是老样子，dp[i][j] 表示的就是问题 pattern(0…i) 和 str(0…j) 的答案，直接说就是 pattern(0…i) 和 str(0…j) 是否匹配

递推方程
把之前 “问题拆解” 中的文字描述转换成状态的表达式就是递推方程：
pattern(i) == str(j) || pattern(i) == '?':
dp[i][j] = dp[i - 1][j - 1]

pattern(i) == '*':
dp[i][j] = dp[i - 1][j] || dp[i][j - 1]

实现
这类问题的状态数组往往需要多开一格，主要是为了考虑空串的情况，这里我就不赘述了。
我想说的是，关于初始化的部分，如果 str 是空的，pattern 最前面有 *，因为 * 是可以匹配空串的，因此这个也需要记录一下，反过来，如果 pattern 是空的，str 只要不是空的就无法匹配，这里就不需要特别记录。

*/




//动态规划，7.5版本
bool f[2000][2000];
class Solution {
public:
    bool isMatch(string s, string p) {
        int n=s.size(),m=p.size();
        for(int i=0;i<=n;i++){
            for(int j=0;j<=m;j++){
                f[i][j]=0;
            }
        }
        f[0][0]=1;
        
        s='0'+s;
        p='0'+p;
        for(int i=1;i<=m;i++){
            if(p[i]=='*')
                f[0][i]=f[0][i-1];
        }
        
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(s[i]==p[j]||p[j]=='?')f[i][j]=f[i-1][j-1];
                else if(p[j]=='*'){
                    f[i][j]=f[i][j-1]||f[i-1][j];
                }
            }
        }
        return f[n][m];
    }
};