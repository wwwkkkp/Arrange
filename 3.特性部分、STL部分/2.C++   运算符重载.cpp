

//2.C++ | 运算符重载

运算符重载遵循的规则
1.除了 类属关系运算符"."、成员指针运算符".*"、作用域运算符"::"、sizeof运算符和三目运算符"?:"以外，C++中的所有运算符都可以重载。
2.不能创建新的运算符。
3.运算符重载实质上是函数重载，因此编译程序对运算符重载的选择，遵循函数重载的选择原则。
4.重载之后的运算符不能改变运算符的优先级和结合性，也不能改变运算符操作数的个数及语法结构。
5.运算符重载不能改变该运算符用于内部类型对象的含义。
6.重载的功能应当与原有功能相类似，避免没有目的地使用重载运算符。

//成员函数运算符
当运算符重载为类的成员函数时，函数的参数个数比原来的操作数要少一个（后置单目运算符除外），这是因为成员函数用this指针隐式地访问了类的一个对象，它充当了运算符函数最左边的操作数。

//友元函数运算符,相当于非成员函数重载
没有this指针，参数一一对应

//两种重载形式的比较:
1.一般情况下,/单目运算符最好重载为类的成员函数；双目运算符则最好重载为类的友元函数。/
2.以下一些双目运算符不能重载为类的友元函数：=、()、[]、->。
3.类型转换函数只能定义为一个类的成员函数而不能定义为类的友元函数。
4.若一个运算符的操作需要修改对象的状态，选择重载为成员函数较好。
5.若运算符所需的操作数（尤其是第一个操作数）希望有/隐式类型转换/，则只能选用友元函数。
6.当运算符函数是一个成员函数时，最左边的操作数（或者只有最左边的操作数）必须是运算符类的一个类对象（或者是对该类对象的引用）。如果左边的操作数必须是一个不同类的对象，或者是一个内部类型的对象，该运算符函数必须作为一个友元函数来实现。//下面有实际例子
7.当需要重载运算符具有可交换性时，选择重载为友元函数。

第6点示例：

CComplex CComplex:: operator+(const CComplex &src)
{
	return CComplex(src.mreal + mreal, src.mimage + mimage);
}
,
/上面为成员函数，可以实现类似 com4 = com1 + 10 的例子，因为10进行了类型转换，把10准换成const CComplex &，但是 com4 = 10 + com1，就不能执行，因为10无法转换/  
/注意：是操作符的左边那个数调用重载函数/

//但是非成员函数就可以
CComplex operator+(const CComplex &lhs, const CComplex &rhs)  // 定义为全局  可实现类似 comp4 = 10 + comp3，左边参数会进行隐式转换
{
	return CComplex(lhs.mreal + rhs.mreal, lhs.mimage + rhs.mimage);
}


重载前置自增操作符
CComplex& CComplex :: operator++()  //取地址符可加可不加
{
	mreal++;
	mimage++;
	return *this;
}

重载后置自增操作符:// 后置单目运算符重载为类的成员函数时，函数要带有一个整型形参。
CComplex CComplex :: operator++(int)
{
	return CComplex(mreal++, mimage++);
}


